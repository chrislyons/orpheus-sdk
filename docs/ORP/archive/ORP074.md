# ORP074 - SDK Enhancement Sprint: Clip Metadata Management (Week 7-8)

**Date:** 2025-10-22
**Status:** Ready for Implementation
**Priority:** HIGH (Blocking OCC v0.2.0 main playback integration)
**Related:** OCC029 (SDK Enhancement Recommendations), OCC037 (Edit Dialog Preview Enhancements), OCC027 (API Contracts)
**Estimated Effort:** 2-3 developer-weeks

---

## Executive Summary

The Orpheus SDK currently lacks the ability to update clip metadata (trim points, fades) after a clip has been registered for playback. This sprint adds three new methods to `TransportController` to enable dynamic clip parameter updates, completing the OCC Edit Dialog → SDK integration path.

**What's Already Complete:**

- ✅ OCC Edit Dialog with preview-mode trim/fade editing
- ✅ AudioEngine infrastructure (`updateClipMetadata()` stub)
- ✅ MainComponent wiring (OK button calls AudioEngine)
- ✅ SessionManager persistence (metadata stored)

**What This Sprint Delivers:**

- ✅ SDK API to update clip trim points dynamically
- ✅ SDK API to update clip fades dynamically
- ✅ Audio callback applies trim/fade in real-time
- ✅ OCC main playback respects edited metadata

---

## Context

### Current Situation

**OCC v0.1.0-alpha** shipped with preview-mode trim/fade editing:

- User edits IN/OUT points and fades in Edit Dialog
- Changes audible in **preview playback** (PreviewPlayer)
- Changes saved to SessionManager
- **Main clip button playback DOES NOT apply changes**

**Root Cause:** SDK's `TransportController::registerClipAudio()` only accepts a file path:

```cpp
// Current SDK API (src/core/transport/transport_controller.h)
SessionGraphError registerClipAudio(ClipHandle handle, const std::string& file_path);
```

Once registered, clip metadata is immutable. No API exists to update trim/fade after registration.

**Workaround:** User must reload clip to grid to apply edited metadata (poor UX).

### Desired Behavior (Post-Sprint)

1. User edits clip in OCC Edit Dialog
2. User clicks OK
3. OCC calls `AudioEngine::updateClipMetadata()`
4. AudioEngine calls **NEW** SDK methods:
   - `TransportController::updateClipTrimPoints(handle, trimIn, trimOut)`
   - `TransportController::updateClipFades(handle, fadeIn, fadeOut, inCurve, outCurve)`
5. SDK updates internal metadata
6. Next main clip button playback applies new trim/fade

---

## API Design

### New Public Methods

Add to `include/orpheus/transport_controller.h`:

```cpp
namespace orpheus {

// Fade curve types
enum class FadeCurve : uint8_t {
    Linear = 0,
    EqualPower = 1,
    Exponential = 2
};

class ITransportController {
public:
    // ... existing methods ...

    /**
     * Update trim points for a registered clip
     *
     * @param handle Clip handle (must be registered via registerClipAudio)
     * @param trimInSamples Trim IN point in samples (0 = start of file)
     * @param trimOutSamples Trim OUT point in samples (file duration = end of file)
     * @return SessionGraphError::OK on success, error code on failure
     *
     * Thread-safe: Can be called from UI thread
     * Takes effect: On next clip start (does not affect currently playing clips)
     *
     * Validation:
     * - trimInSamples must be >= 0 and < file duration
     * - trimOutSamples must be > trimInSamples and <= file duration
     * - If invalid, returns SessionGraphError::InvalidClipTrimPoints
     */
    virtual SessionGraphError updateClipTrimPoints(ClipHandle handle,
                                                   int64_t trimInSamples,
                                                   int64_t trimOutSamples) = 0;

    /**
     * Update fade settings for a registered clip
     *
     * @param handle Clip handle (must be registered via registerClipAudio)
     * @param fadeInSeconds Fade-in duration in seconds (0.0 = no fade)
     * @param fadeOutSeconds Fade-out duration in seconds (0.0 = no fade)
     * @param fadeInCurve Fade-in curve type (Linear, EqualPower, Exponential)
     * @param fadeOutCurve Fade-out curve type (Linear, EqualPower, Exponential)
     * @return SessionGraphError::OK on success, error code on failure
     *
     * Thread-safe: Can be called from UI thread
     * Takes effect: On next clip start (does not affect currently playing clips)
     *
     * Fade behavior:
     * - Fade-in: Applied from trimInSamples (0.0 → 1.0 gain over N seconds)
     * - Fade-out: Applied before trimOutSamples (1.0 → 0.0 gain over N seconds)
     * - Fade curves:
     *   - Linear: y = x
     *   - EqualPower: y = sin(x * π/2)  [smooth crossfades]
     *   - Exponential: y = x²  [dramatic effect]
     *
     * Validation:
     * - fadeInSeconds must be >= 0.0 and <= (trimOutSamples - trimInSamples) / sampleRate
     * - fadeOutSeconds must be >= 0.0 and <= (trimOutSamples - trimInSamples) / sampleRate
     * - If fades overlap, fade-out takes precedence
     */
    virtual SessionGraphError updateClipFades(ClipHandle handle,
                                             double fadeInSeconds,
                                             double fadeOutSeconds,
                                             FadeCurve fadeInCurve,
                                             FadeCurve fadeOutCurve) = 0;

    /**
     * Get current trim points for a clip (query only)
     *
     * @param handle Clip handle
     * @param[out] trimInSamples Current trim IN point
     * @param[out] trimOutSamples Current trim OUT point
     * @return SessionGraphError::OK on success, error code if clip not found
     *
     * Thread-safe: Can be called from any thread
     */
    virtual SessionGraphError getClipTrimPoints(ClipHandle handle,
                                               int64_t& trimInSamples,
                                               int64_t& trimOutSamples) const = 0;
};

} // namespace orpheus
```

### Error Codes

Add to `include/orpheus/session_graph_error.h`:

```cpp
enum class SessionGraphError {
    // ... existing errors ...

    InvalidClipTrimPoints = 18,  // Trim IN >= trim OUT, or out of bounds
    InvalidFadeDuration = 19,    // Fade duration > clip duration
    ClipNotRegistered = 20       // Clip handle not found
};
```

---

## Implementation Plan

### Phase 1: Data Model Extension (2 hours)

**File:** `src/core/transport/clip_playback_state.h` (internal SDK structure)

Add trim/fade fields to existing `ClipPlaybackState`:

```cpp
struct ClipPlaybackState {
    // ... existing fields ...

    // Trim points (default: full file)
    int64_t trimInSamples = 0;
    int64_t trimOutSamples = INT64_MAX;

    // Fade settings (default: no fades)
    double fadeInSeconds = 0.0;
    double fadeOutSeconds = 0.0;
    FadeCurve fadeInCurve = FadeCurve::Linear;
    FadeCurve fadeOutCurve = FadeCurve::Linear;

    // Cached values (computed in update method)
    int64_t fadeInSamples = 0;
    int64_t fadeOutSamples = 0;

    void updateFadeSamples(uint32_t sampleRate) {
        fadeInSamples = static_cast<int64_t>(fadeInSeconds * sampleRate);
        fadeOutSamples = static_cast<int64_t>(fadeOutSeconds * sampleRate);
    }
};
```

**Testing:**

- Unit test: Verify fadeInSamples/fadeOutSamples calculation at 48kHz, 44.1kHz, 96kHz
- Unit test: Verify default values match file duration

---

### Phase 2: API Implementation (4 hours)

**File:** `src/core/transport/transport_controller.cpp`

Implement three new methods in `TransportController` class:

```cpp
SessionGraphError TransportController::updateClipTrimPoints(ClipHandle handle,
                                                            int64_t trimInSamples,
                                                            int64_t trimOutSamples) {
    // 1. Find clip in m_clips map
    auto it = m_clips.find(handle);
    if (it == m_clips.end()) {
        return SessionGraphError::ClipNotRegistered;
    }

    ClipPlaybackState& clip = it->second;

    // 2. Validate trim points
    if (trimInSamples < 0 || trimInSamples >= clip.fileDurationSamples) {
        return SessionGraphError::InvalidClipTrimPoints;
    }

    if (trimOutSamples <= trimInSamples || trimOutSamples > clip.fileDurationSamples) {
        return SessionGraphError::InvalidClipTrimPoints;
    }

    // 3. Update trim points (atomic update for thread safety)
    clip.trimInSamples.store(trimInSamples, std::memory_order_release);
    clip.trimOutSamples.store(trimOutSamples, std::memory_order_release);

    LOG_DEBUG("Updated trim points for clip " << handle
              << ": [" << trimInSamples << ", " << trimOutSamples << "]");

    return SessionGraphError::OK;
}

SessionGraphError TransportController::updateClipFades(ClipHandle handle,
                                                       double fadeInSeconds,
                                                       double fadeOutSeconds,
                                                       FadeCurve fadeInCurve,
                                                       FadeCurve fadeOutCurve) {
    // 1. Find clip in m_clips map
    auto it = m_clips.find(handle);
    if (it == m_clips.end()) {
        return SessionGraphError::ClipNotRegistered;
    }

    ClipPlaybackState& clip = it->second;

    // 2. Validate fade durations
    int64_t clipDuration = clip.trimOutSamples - clip.trimInSamples;
    double clipDurationSeconds = static_cast<double>(clipDuration) / m_sampleRate;

    if (fadeInSeconds < 0.0 || fadeInSeconds > clipDurationSeconds) {
        return SessionGraphError::InvalidFadeDuration;
    }

    if (fadeOutSeconds < 0.0 || fadeOutSeconds > clipDurationSeconds) {
        return SessionGraphError::InvalidFadeDuration;
    }

    // 3. Update fade settings (atomic update for thread safety)
    clip.fadeInSeconds.store(fadeInSeconds, std::memory_order_release);
    clip.fadeOutSeconds.store(fadeOutSeconds, std::memory_order_release);
    clip.fadeInCurve.store(fadeInCurve, std::memory_order_release);
    clip.fadeOutCurve.store(fadeOutCurve, std::memory_order_release);

    // 4. Recompute cached fade sample counts
    clip.updateFadeSamples(m_sampleRate);

    LOG_DEBUG("Updated fades for clip " << handle
              << ": IN=" << fadeInSeconds << "s (" << fadeInCurveToString(fadeInCurve) << "), "
              << "OUT=" << fadeOutSeconds << "s (" << fadeOutCurveToString(fadeOutCurve) << ")");

    return SessionGraphError::OK;
}

SessionGraphError TransportController::getClipTrimPoints(ClipHandle handle,
                                                         int64_t& trimInSamples,
                                                         int64_t& trimOutSamples) const {
    auto it = m_clips.find(handle);
    if (it == m_clips.end()) {
        return SessionGraphError::ClipNotRegistered;
    }

    const ClipPlaybackState& clip = it->second;
    trimInSamples = clip.trimInSamples.load(std::memory_order_acquire);
    trimOutSamples = clip.trimOutSamples.load(std::memory_order_acquire);

    return SessionGraphError::OK;
}
```

**Testing:**

- Unit test: Update trim points, verify getter returns new values
- Unit test: Update fades, verify cached sample counts recomputed
- Unit test: Invalid trim points return error (IN >= OUT, negative values, out of bounds)
- Unit test: Invalid fade durations return error (negative, > clip duration)
- Unit test: Clip not registered returns ClipNotRegistered error

---

### Phase 3: Audio Callback Integration (6 hours)

**File:** `src/core/transport/transport_controller.cpp`

Modify `processAudio()` method to apply trim/fade:

```cpp
void TransportController::processAudio(float** output_buffers, size_t num_channels, size_t num_frames) {
    // Clear output buffers
    for (size_t ch = 0; ch < num_channels; ++ch) {
        std::memset(output_buffers[ch], 0, num_frames * sizeof(float));
    }

    // Process each active clip
    for (auto& [handle, clip] : m_activeClips) {
        // Load trim/fade settings (atomic read)
        int64_t trimIn = clip.trimInSamples.load(std::memory_order_acquire);
        int64_t trimOut = clip.trimOutSamples.load(std::memory_order_acquire);
        int64_t fadeInSamples = clip.fadeInSamples.load(std::memory_order_acquire);
        int64_t fadeOutSamples = clip.fadeOutSamples.load(std::memory_order_acquire);
        FadeCurve fadeInCurve = clip.fadeInCurve.load(std::memory_order_acquire);
        FadeCurve fadeOutCurve = clip.fadeOutCurve.load(std::memory_order_acquire);

        // Process audio frame-by-frame
        for (size_t i = 0; i < num_frames; ++i) {
            int64_t filePosition = clip.currentPosition + i;

            // Check if position is within trim range
            if (filePosition < trimIn || filePosition >= trimOut) {
                // Outside trim range → stop clip
                clip.state = PlaybackState::Stopping;
                continue;
            }

            // Read audio sample from file buffer
            float sample = readAudioSample(clip, filePosition);

            // Calculate fade gain
            float gain = 1.0f;

            // Fade-in: First N samples from trim IN
            int64_t relativePos = filePosition - trimIn;
            if (fadeInSamples > 0 && relativePos < fadeInSamples) {
                float fadeInPos = static_cast<float>(relativePos) / fadeInSamples;
                gain *= calculateFadeGain(fadeInPos, fadeInCurve);
            }

            // Fade-out: Last N samples before trim OUT
            int64_t trimmedDuration = trimOut - trimIn;
            if (fadeOutSamples > 0 && relativePos >= (trimmedDuration - fadeOutSamples)) {
                int64_t fadeOutRelativePos = relativePos - (trimmedDuration - fadeOutSamples);
                float fadeOutPos = static_cast<float>(fadeOutRelativePos) / fadeOutSamples;
                gain *= (1.0f - calculateFadeGain(fadeOutPos, fadeOutCurve));
            }

            // Apply gain to output
            for (size_t ch = 0; ch < num_channels; ++ch) {
                output_buffers[ch][i] += sample * gain;
            }
        }

        // Update clip position
        clip.currentPosition += num_frames;
    }
}

// Helper: Calculate fade gain based on curve type
float TransportController::calculateFadeGain(float normalizedPosition, FadeCurve curve) const {
    switch (curve) {
        case FadeCurve::Linear:
            return normalizedPosition;

        case FadeCurve::EqualPower:
            return std::sin(normalizedPosition * M_PI_2);  // sin(x * π/2)

        case FadeCurve::Exponential:
            return normalizedPosition * normalizedPosition;  // x²

        default:
            return normalizedPosition;
    }
}
```

**Testing:**

- Integration test: Load clip, set trim IN at 1s, verify playback starts at 1s
- Integration test: Load clip, set trim OUT at 5s (file is 10s), verify playback stops at 5s
- Integration test: Set fade-in 0.5s, verify audible gain ramp at start
- Integration test: Set fade-out 1.0s, verify audible gain ramp at end
- Integration test: Verify Linear, EqualPower, Exponential curves produce different results
- Stress test: Update trim/fade while clip is playing → verify no crashes, glitches

---

### Phase 4: OCC Integration (2 hours)

**File:** `apps/clip-composer/Source/Audio/AudioEngine.cpp`

Remove TODO and call SDK methods:

```cpp
bool AudioEngine::updateClipMetadata(int buttonIndex, int64_t trimInSamples, int64_t trimOutSamples,
                                     double fadeInSeconds, double fadeOutSeconds,
                                     const juce::String& fadeInCurve, const juce::String& fadeOutCurve) {
    if (buttonIndex < 0 || buttonIndex >= 48)
        return false;

    auto handle = m_clipHandles[buttonIndex];
    if (handle == 0) {
        DBG("AudioEngine: Cannot update metadata - no clip loaded at button " << buttonIndex);
        return false;
    }

    if (!m_transportController) {
        DBG("AudioEngine: No transport controller");
        return false;
    }

    // Map fade curve strings to SDK enum
    orpheus::FadeCurve fadeInCurveEnum = orpheus::FadeCurve::Linear;
    if (fadeInCurve == "EqualPower") fadeInCurveEnum = orpheus::FadeCurve::EqualPower;
    else if (fadeInCurve == "Exponential") fadeInCurveEnum = orpheus::FadeCurve::Exponential;

    orpheus::FadeCurve fadeOutCurveEnum = orpheus::FadeCurve::Linear;
    if (fadeOutCurve == "EqualPower") fadeOutCurveEnum = orpheus::FadeCurve::EqualPower;
    else if (fadeOutCurve == "Exponential") fadeOutCurveEnum = orpheus::FadeCurve::Exponential;

    // Call SDK methods
    auto trimResult = m_transportController->updateClipTrimPoints(handle, trimInSamples, trimOutSamples);
    if (trimResult != orpheus::SessionGraphError::OK) {
        DBG("AudioEngine: Failed to update trim points: " << static_cast<int>(trimResult));
        return false;
    }

    auto fadeResult = m_transportController->updateClipFades(handle, fadeInSeconds, fadeOutSeconds,
                                                             fadeInCurveEnum, fadeOutCurveEnum);
    if (fadeResult != orpheus::SessionGraphError::OK) {
        DBG("AudioEngine: Failed to update fades: " << static_cast<int>(fadeResult));
        return false;
    }

    DBG("AudioEngine: Successfully updated clip metadata for button " << buttonIndex
        << " - Trim: [" << trimInSamples << ", " << trimOutSamples << "]"
        << ", Fade IN: " << fadeInSeconds << "s (" << fadeInCurve << ")"
        << ", Fade OUT: " << fadeOutSeconds << "s (" << fadeOutCurve << ")");

    return true;
}
```

**Testing:**

- Manual test: Edit clip in OCC → OK → Play main button → Verify trim/fade applied
- Manual test: Edit IN point to 2s → Verify playback starts at 2s (not 0s)
- Manual test: Set fade-in 1.0s → Verify audible fade on main playback
- Manual test: Compare preview vs main playback → Should match exactly

---

## Additional SDK Features (Bonus)

### Feature 1: Bulk Metadata Update (Low Priority)

**API:**

```cpp
struct ClipMetadataUpdate {
    ClipHandle handle;
    int64_t trimInSamples;
    int64_t trimOutSamples;
    double fadeInSeconds;
    double fadeOutSeconds;
    FadeCurve fadeInCurve;
    FadeCurve fadeOutCurve;
};

SessionGraphError updateMultipleClips(const std::vector<ClipMetadataUpdate>& updates);
```

**Use Case:** User edits multiple clips in batch (e.g., apply same fade to all clips in group)

**Estimated Effort:** +2 hours

---

### Feature 2: Clip Metadata Serialization (Medium Priority)

**API:**

```cpp
struct ClipMetadataSnapshot {
    ClipHandle handle;
    int64_t trimInSamples;
    int64_t trimOutSamples;
    double fadeInSeconds;
    double fadeOutSeconds;
    FadeCurve fadeInCurve;
    FadeCurve fadeOutCurve;
};

std::vector<ClipMetadataSnapshot> exportAllClipMetadata() const;
SessionGraphError importAllClipMetadata(const std::vector<ClipMetadataSnapshot>& metadata);
```

**Use Case:** Session save/load includes trim/fade settings

**Estimated Effort:** +3 hours

---

### Feature 3: Real-Time Fade Adjustment (Low Priority)

**API:**

```cpp
// Update fades on currently playing clip (smooth transition)
SessionGraphError updateClipFadesRealTime(ClipHandle handle,
                                          double fadeInSeconds,
                                          double fadeOutSeconds);
```

**Use Case:** User adjusts fade while clip is playing (DJ-style live editing)

**Estimated Effort:** +4 hours (requires smoothing logic to avoid clicks)

---

## Testing Strategy

### Unit Tests (GoogleTest)

**File:** `tests/transport/clip_metadata_test.cpp`

```cpp
TEST(ClipMetadata, UpdateTrimPoints) {
    auto transport = createTransportController();
    auto handle = registerTestClip(transport, "test.wav", 48000, 480000);  // 10 seconds

    // Set trim IN to 2s, OUT to 8s
    auto result = transport->updateClipTrimPoints(handle, 96000, 384000);
    EXPECT_EQ(result, SessionGraphError::OK);

    // Verify getter
    int64_t trimIn, trimOut;
    transport->getClipTrimPoints(handle, trimIn, trimOut);
    EXPECT_EQ(trimIn, 96000);
    EXPECT_EQ(trimOut, 384000);
}

TEST(ClipMetadata, InvalidTrimPoints) {
    auto transport = createTransportController();
    auto handle = registerTestClip(transport, "test.wav", 48000, 480000);

    // IN >= OUT (invalid)
    auto result1 = transport->updateClipTrimPoints(handle, 300000, 200000);
    EXPECT_EQ(result1, SessionGraphError::InvalidClipTrimPoints);

    // Negative IN (invalid)
    auto result2 = transport->updateClipTrimPoints(handle, -1000, 400000);
    EXPECT_EQ(result2, SessionGraphError::InvalidClipTrimPoints);

    // OUT > file duration (invalid)
    auto result3 = transport->updateClipTrimPoints(handle, 0, 500000);
    EXPECT_EQ(result3, SessionGraphError::InvalidClipTrimPoints);
}

TEST(ClipMetadata, UpdateFades) {
    auto transport = createTransportController();
    auto handle = registerTestClip(transport, "test.wav", 48000, 480000);

    // Set fade-in 0.5s, fade-out 1.0s, exponential curves
    auto result = transport->updateClipFades(handle, 0.5, 1.0,
                                            FadeCurve::Exponential, FadeCurve::Exponential);
    EXPECT_EQ(result, SessionGraphError::OK);
}

TEST(ClipMetadata, FadeCurveCalculation) {
    auto transport = createTransportController();

    // Linear: f(0.5) = 0.5
    EXPECT_NEAR(transport->calculateFadeGain(0.5f, FadeCurve::Linear), 0.5f, 0.01f);

    // EqualPower: f(0.5) = sin(0.5 * π/2) ≈ 0.707
    EXPECT_NEAR(transport->calculateFadeGain(0.5f, FadeCurve::EqualPower), 0.707f, 0.01f);

    // Exponential: f(0.5) = 0.5² = 0.25
    EXPECT_NEAR(transport->calculateFadeGain(0.5f, FadeCurve::Exponential), 0.25f, 0.01f);
}
```

### Integration Tests

**File:** `tests/transport/clip_playback_integration_test.cpp`

```cpp
TEST(Integration, TrimPointsAppliedOnPlayback) {
    auto transport = createTransportController();
    auto driver = createDummyAudioDriver();

    // Load 10-second clip
    auto handle = registerTestClip(transport, "10sec_silence.wav", 48000, 480000);

    // Set trim: start at 2s, end at 8s (6 seconds total)
    transport->updateClipTrimPoints(handle, 96000, 384000);

    // Start playback
    transport->startClip(handle);

    // Process 5 seconds of audio
    float* buffer[2] = {new float[48000 * 5], new float[48000 * 5]};
    transport->processAudio(buffer, 2, 48000 * 5);

    // Verify clip still playing (haven't reached 8s yet)
    EXPECT_EQ(transport->getClipState(handle), PlaybackState::Playing);

    // Process 2 more seconds
    transport->processAudio(buffer, 2, 48000 * 2);

    // Verify clip stopped (reached 8s trim OUT)
    EXPECT_EQ(transport->getClipState(handle), PlaybackState::Stopped);

    delete[] buffer[0];
    delete[] buffer[1];
}

TEST(Integration, FadeInAppliedOnPlayback) {
    auto transport = createTransportController();

    // Load clip with 1kHz sine wave
    auto handle = registerTestClip(transport, "1khz_sine.wav", 48000, 48000);  // 1 second

    // Set fade-in: 0.5 seconds linear
    transport->updateClipFades(handle, 0.5, 0.0, FadeCurve::Linear, FadeCurve::Linear);

    // Start playback
    transport->startClip(handle);

    // Process first 0.1 seconds
    float* buffer[2] = {new float[4800], new float[4800]};
    transport->processAudio(buffer, 2, 4800);

    // Verify fade-in applied (gain should be ~0.2 at 0.1s into 0.5s fade)
    // First sample should be near 0.0, last sample near 0.2
    EXPECT_NEAR(buffer[0][0], 0.0f, 0.05f);
    EXPECT_NEAR(buffer[0][4799], 0.2f, 0.05f);

    delete[] buffer[0];
    delete[] buffer[1];
}
```

### Manual Testing (OCC)

**Test Plan:**

1. Load clip (e.g., "test.wav" 10 seconds)
2. Open Edit Dialog
3. Set IN point to 2s, OUT point to 8s
4. Set fade-in 1.0s Linear, fade-out 0.5s Exponential
5. Click OK
6. Play main clip button
7. **Verify:** Playback starts at 2s (not 0s)
8. **Verify:** Playback stops at 8s (not 10s)
9. **Verify:** Audible 1-second fade-in at start
10. **Verify:** Audible 0.5-second fade-out before end

**Acceptance Criteria:**

- ✅ Trim points applied correctly (±10ms tolerance)
- ✅ Fade-in audible and smooth (no clicks)
- ✅ Fade-out audible and smooth (no clicks)
- ✅ Preview playback matches main playback exactly
- ✅ No crashes, glitches, or audio dropouts

---

## Implementation Schedule

### Day 1 (8 hours)

- **Morning (4h):** Phase 1 (Data Model) + Phase 2 (API Implementation)
- **Afternoon (4h):** Unit tests for Phases 1-2

### Day 2 (8 hours)

- **Morning (4h):** Phase 3 (Audio Callback Integration)
- **Afternoon (4h):** Integration tests for Phase 3

### Day 3 (4 hours)

- **Morning (2h):** Phase 4 (OCC Integration)
- **Afternoon (2h):** Manual testing, bug fixes

**Total Effort:** 20 hours (2.5 developer-days)

---

## Definition of Done

- [ ] All three new methods implemented in `TransportController`
- [ ] Error enum extended with new codes
- [ ] Unit tests pass (100% code coverage for new methods)
- [ ] Integration tests pass (trim/fade applied correctly)
- [ ] OCC main playback respects edited trim/fade
- [ ] Manual test plan executed and passed
- [ ] No memory leaks (valgrind/sanitizers clean)
- [ ] Code reviewed by 1+ SDK team members
- [ ] API documentation updated (Doxygen comments)
- [ ] OCC v0.2.0-alpha release candidate built and tested

---

## Dependencies

### External Libraries

- None (uses existing SDK infrastructure)

### OCC Changes Required

- **AudioEngine.cpp:165-192** - Remove TODO, add SDK method calls (Phase 4)
- **Build system** - No changes (SDK headers already included)

### Backward Compatibility

- ✅ **Fully backward compatible** - New methods, no breaking changes
- ✅ Existing clips without trim/fade continue to work (defaults: full file, no fades)
- ✅ ABI versioning unchanged (adding methods to interface is safe)

---

## Risk Assessment

| Risk                                      | Probability | Impact | Mitigation                                    |
| ----------------------------------------- | ----------- | ------ | --------------------------------------------- |
| Thread-safety issues (UI ↔ audio thread) | Medium      | High   | Use atomic operations, extensive testing      |
| Audio glitches during fade calculations   | Low         | Medium | Pre-compute fade samples, optimize math       |
| Performance regression (CPU usage)        | Low         | Medium | Profile before/after, target <5% overhead     |
| Incorrect fade curve math                 | Low         | High   | Unit tests with known values, manual audition |
| OCC integration breaks existing features  | Low         | Medium | Regression testing, beta feedback             |

---

## Success Metrics

**Immediate (Post-Sprint):**

- ✅ OCC main playback applies edited trim/fade (100% success rate)
- ✅ No audio dropouts during trim/fade (0 buffer underruns in 10 test runs)
- ✅ CPU overhead <5% (measured with 16 simultaneous clips)

**Long-Term (Post-OCC v0.2.0 Release):**

- ✅ User feedback: "Main playback matches preview" (>90% satisfaction)
- ✅ No bug reports related to trim/fade in first 30 days
- ✅ Feature used by >80% of beta testers

---

## References

[1] OCC029 - SDK Enhancement Recommendations (comprehensive gap analysis)
[2] OCC027 - API Contracts (interface specifications)
[3] OCC037 - Edit Dialog Preview Enhancements (completed work)
[4] OCC022 - Clip Metadata Schema (data model reference)
[5] PreviewPlayer.cpp:226-306 - Reference implementation (fade processing)

---

## Appendix A: Fade Curve Formulas

**Linear:**

```
f(x) = x
Range: [0.0, 1.0]
Use case: Simple fades, broadcasting
```

**EqualPower:**

```
f(x) = sin(x * π/2)
Range: [0.0, 1.0]
Use case: Crossfades, smooth transitions
Mathematical property: f(x)² + f(1-x)² = 1  (constant power)
```

**Exponential:**

```
f(x) = x²
Range: [0.0, 1.0]
Use case: Dramatic effect, sound design
Alternative: x³ for even steeper curve (future enhancement)
```

---

## Appendix B: Thread Safety Guarantees

**UI Thread (Safe Operations):**

- `updateClipTrimPoints()` - Atomic write to trim IN/OUT
- `updateClipFades()` - Atomic write to fade settings
- `getClipTrimPoints()` - Atomic read (query only)

**Audio Thread (Safe Operations):**

- Read trim/fade settings via `std::memory_order_acquire`
- No blocking, no allocations, deterministic processing

**Synchronization:**

- No locks required (atomic operations only)
- Memory barriers ensure visibility (acquire/release semantics)
- Audio thread never writes trim/fade (read-only)

---

**Status:** ✅ **READY FOR IMPLEMENTATION**
**Next Step:** Assign to SDK developer, create GitHub issue/PR
**Blocked On:** None (all dependencies complete)
