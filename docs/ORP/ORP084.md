# ORP084 - OCC SDK Enhancement Sprint: Playback Semantics & Safety

**Document ID:** ORP084
**Version:** 1.0
**Status:** Authoritative
**Date:** 2025-10-26
**Author:** SDK Core Team
**Related Plans:** ORP076 (SDK Enhancement Sprint), ORP077 (SDK Core Quality), OCC021 (Product Vision)

---

## Executive Summary

This sprint addresses **critical heap-use-after-free crashes** in the TransportController and implements **high-priority playback semantics** requested by the OCC team to enable professional soundboard workflows.

**Sprint Goal:** Eliminate audio thread safety violations and complete playback position/timing semantics for OCC v0.3.0

**Timeline:** 2 working days (12-16 hours)
**Critical Path:** Safety Fix → Position Tracking → OUT Point Enforcement → Fade Semantics → Batch APIs

**Business Impact:**

- **Unblocks OCC tab switching** - Currently workaround stops all clips on tab change
- **Enables Preview Player** - Requires position tracking for waveform playhead
- **Enables professional crossfades** - "Stop Others On Play" with simultaneous fade-out/fade-in
- **Completes broadcast workflows** - 75 fps timecode resolution for SMPTE compatibility

---

## Table of Contents

1. [Critical Issue Analysis](#critical-issue-analysis)
2. [High Priority Features](#high-priority-features)
3. [Medium Priority Features](#medium-priority-features)
4. [Low Priority Features](#low-priority-features)
5. [Technical Approach](#technical-approach)
6. [Implementation Plan](#implementation-plan)
7. [Testing Strategy](#testing-strategy)
8. [Acceptance Criteria](#acceptance-criteria)
9. [Risks & Mitigations](#risks--mitigations)
10. [Success Metrics](#success-metrics)
11. [Files Modified Summary](#files-modified-summary)
12. [Timeline](#timeline)

---

## Critical Issue Analysis

### Issue #1: Heap-Use-After-Free Crash ⚠️ CRITICAL

**Priority:** P0 (Blocker for production use)
**Location:** `src/core/transport/transport_controller.cpp:225` (processAudio)
**Impact:** Application crash when user switches tabs during playback

#### Root Cause

**Race condition between UI thread and audio thread:**

```
Timeline: User switches tabs during clip playback

T=0ms    [UI Thread]    User clicks Tab 2
T=1ms    [UI Thread]    SessionManager::loadClip(newClip)
T=2ms    [UI Thread]    TransportController::registerClipAudio(newClip)
T=3ms    [UI Thread]    OLD AudioFileReader destroyed (unique_ptr replacement)
T=4ms    [Audio Thread] processAudio() accessing OLD AudioFileReader → CRASH
         ↓ Heap-use-after-free detected by AddressSanitizer
```

**Current Architecture (BROKEN):**

```cpp
// AudioFileEntry in transport_controller.h
struct AudioFileEntry {
  std::unique_ptr<IAudioFileReader> reader;  // ❌ No lifetime protection
  AudioFileMetadata metadata;
  // ... metadata fields
};

// Clip registration (UI thread) - DESTROYS old reader immediately
SessionGraphError TransportController::registerClipAudio(ClipHandle handle,
                                                         const std::string& file_path) {
  std::lock_guard<std::mutex> lock(m_audioFilesMutex);

  auto reader = createAudioFileReader();
  auto result = reader->open(file_path);

  AudioFileEntry entry;
  entry.reader = std::move(reader);  // ❌ Old reader destroyed HERE
  m_audioFiles[handle] = std::move(entry);  // ❌ unique_ptr assignment destroys old

  return SessionGraphError::OK;
}

// Audio callback (audio thread) - Accesses dangling pointer
void TransportController::processAudio(float** outputBuffers, size_t numChannels,
                                       size_t numFrames) {
  for (size_t i = 0; i < m_activeClipCount; ++i) {
    ActiveClip& clip = m_activeClips[i];

    // ❌ clip.audioReader points to DESTROYED AudioFileReader
    if (!clip.audioReader || !clip.audioReader->isOpen()) {  // ❌ CRASH HERE (line 225)
      continue;
    }

    // ❌ If we survive the null check, readSamples() will crash
    auto readResult = clip.audioReader->readSamples(buffer, framesToRead);
  }
}
```

#### Workaround in OCC (Limiting UX)

**Current behavior:** OCC stops all clips when switching tabs to avoid crash

```cpp
// apps/clip-composer/src/SessionManager.cpp (current workaround)
void SessionManager::switchToTab(int tabIndex) {
  // ❌ Must stop ALL clips to prevent crash
  m_transport->stopAllClips();  // User loses all active playback

  // Now safe to load new clips
  loadClipsForTab(tabIndex);
}
```

**Impact on User Experience:**

- Users cannot switch tabs during playback
- Background loops (ambience, music beds) get interrupted
- Professional workflows broken (live theater, broadcast)

#### Proposed Fix: Shared Pointer Lifetime Management

**Solution:** Use `std::shared_ptr<IAudioFileReader>` for reference-counted lifetime management

**New Architecture (SAFE):**

```cpp
// AudioFileEntry in transport_controller.h
struct AudioFileEntry {
  std::shared_ptr<IAudioFileReader> reader;  // ✅ Reference-counted lifetime
  AudioFileMetadata metadata;
  // ... metadata fields
};

// ActiveClip in transport_controller.h
struct ActiveClip {
  ClipHandle handle;
  // ... position fields

  std::shared_ptr<IAudioFileReader> audioReader;  // ✅ Strong reference (not raw pointer)
  uint16_t numChannels;
};

// Clip registration (UI thread) - Old reader survives until audio thread releases
SessionGraphError TransportController::registerClipAudio(ClipHandle handle,
                                                         const std::string& file_path) {
  std::lock_guard<std::mutex> lock(m_audioFilesMutex);

  auto reader = std::make_shared<AudioFileReaderImpl>();  // ✅ shared_ptr
  auto result = reader->open(file_path);

  AudioFileEntry entry;
  entry.reader = reader;  // ✅ Shared ownership
  m_audioFiles[handle] = std::move(entry);

  // ✅ Old reader NOT destroyed yet - audio thread still holds reference

  return SessionGraphError::OK;
}

// Active clip setup (audio thread)
void TransportController::addActiveClip(ClipHandle handle) {
  std::shared_ptr<IAudioFileReader> reader;  // ✅ Strong reference

  {
    std::lock_guard<std::mutex> lock(m_audioFilesMutex);
    auto it = m_audioFiles.find(handle);
    if (it != m_audioFiles.end()) {
      reader = it->second.reader;  // ✅ Increment ref count (thread-safe)
    }
  }

  ActiveClip& clip = m_activeClips[m_activeClipCount++];
  clip.audioReader = reader;  // ✅ Audio thread holds strong reference
}

// Audio callback (audio thread) - SAFE
void TransportController::processAudio(float** outputBuffers, size_t numChannels,
                                       size_t numFrames) {
  for (size_t i = 0; i < m_activeClipCount; ++i) {
    ActiveClip& clip = m_activeClips[i];

    // ✅ Reader stays alive as long as clip is active (ref count > 0)
    if (!clip.audioReader || !clip.audioReader->isOpen()) {  // ✅ SAFE
      continue;
    }

    // ✅ Reader guaranteed valid for duration of callback
    auto readResult = clip.audioReader->readSamples(buffer, framesToRead);
  }
}

// Clip removal (audio thread) - Reader destroyed when last reference dropped
void TransportController::removeActiveClip(ClipHandle handle) {
  // ... find and remove clip

  // ✅ When clip is removed, audioReader goes out of scope
  // ✅ If this was the last reference, AudioFileReader destructor runs HERE (audio thread)
  // ✅ If UI thread still holds reference (in m_audioFiles), reader survives
}
```

**Timeline with Fix:**

```
T=0ms    [UI Thread]    User clicks Tab 2
T=1ms    [UI Thread]    SessionManager::loadClip(newClip)
T=2ms    [UI Thread]    TransportController::registerClipAudio(newClip)
T=3ms    [UI Thread]    m_audioFiles[handle].reader = newReader (ref count: 1)
         ✅ OLD reader ref count decremented BUT NOT DESTROYED (audio thread still holds ref)
T=4ms    [Audio Thread] processAudio() accessing OLD AudioFileReader → ✅ SAFE
         ✅ OLD reader still alive (ref count: 1 from ActiveClip.audioReader)
T=5ms    [Audio Thread] Clip finishes → removeActiveClip() → audioReader reset
         ✅ OLD reader ref count: 0 → destructor runs on audio thread (SAFE)
```

#### Broadcast-Safe Considerations

**Concern:** `std::shared_ptr` uses atomic reference counting - is this audio-thread safe?

**Answer:** ✅ YES - with caveats:

1. **Reference count increment/decrement is lock-free atomic** (no mutex, no syscalls)
2. **Destructor runs on thread that releases last reference** (audio thread in our case)
3. **Performance:** ~5-10 CPU cycles for atomic increment/decrement (negligible)
4. **Memory:** +16 bytes per `shared_ptr` (8 bytes pointer + 8 bytes control block pointer)

**Validation Required:**

- Profile with AddressSanitizer + ThreadSanitizer
- Measure CPU overhead with 32 active clips
- Verify destructor runs on audio thread (acceptable for IAudioFileReader::close())

**Alternative Considered (Rejected):** Custom lock-free reference counting

- **Reason:** `std::shared_ptr` is industry-standard, well-tested, compiler-optimized
- **Tradeoff:** Slight overhead vs. correctness and maintainability

---

## High Priority Features

### Feature #2: Position Tracking API

**Priority:** P1 (Enables Preview Player waveform)
**Effort:** 1 hour

#### Requirements

**API Signature:**

```cpp
/// Get current playback position for a clip
///
/// @param handle Clip handle (must be registered)
/// @param[out] positionTicks Position in 75 fps "ticks" (1/75 second)
/// @return SessionGraphError::OK on success, error code on failure
///
/// Thread-safe: Can be called from UI thread while audio thread is running
/// Performance: <100 CPU cycles (atomic read + arithmetic)
///
/// Resolution: 75 fps (broadcast timecode standard)
/// - 1 tick = 1/75 second = ~13.33 ms @ 48kHz = 640 samples
/// - Example: 30 fps waveform updates → query every 2.5 ticks
///
/// Use Cases:
/// - Preview Player waveform playhead (30 FPS updates)
/// - Elapsed/remaining time display
/// - Position inheritance when switching from Edit Dialog to main grid
virtual SessionGraphError getClipPosition(ClipHandle handle, int64_t& positionTicks) const = 0;
```

**Why 75 fps?**

- SMPTE timecode standard: 24, 25, 29.97, 30, 50, 59.94, 60 fps
- 75 fps divides evenly: 24 (3x), 25 (3x), 30 (2.5x), 50 (1.5x), 60 (1.25x)
- Broadcast-safe: Used in professional audio/video workflows [1]

#### Implementation

**Data Model Changes:**

```cpp
// ActiveClip in transport_controller.h
struct ActiveClip {
  ClipHandle handle;
  int64_t startSample;   // Absolute timeline position when clip started
  std::atomic<int64_t> currentSample;  // ✅ Current position within clip (make atomic)

  // ... rest unchanged
};
```

**Implementation:**

```cpp
SessionGraphError TransportController::getClipPosition(ClipHandle handle,
                                                       int64_t& positionTicks) const {
  if (handle == 0) {
    return SessionGraphError::InvalidHandle;
  }

  // Find active clip (check audio thread state from UI thread - lock-free read)
  for (size_t i = 0; i < m_activeClipCount; ++i) {
    if (m_activeClips[i].handle == handle) {
      const ActiveClip& clip = m_activeClips[i];

      // Atomic read of current position (thread-safe)
      int64_t currentSample = clip.currentSample.load(std::memory_order_acquire);

      // Load trim IN point (position is relative to trim IN)
      int64_t trimIn = clip.trimInSamples.load(std::memory_order_acquire);

      // Calculate relative position from trim IN (NOT absolute timeline)
      int64_t relativeSample = currentSample - trimIn;

      // Convert samples to 75 fps ticks
      // tick = (sample / sampleRate) * 75
      // Optimize: tick = (sample * 75) / sampleRate
      positionTicks = (relativeSample * 75) / static_cast<int64_t>(m_sampleRate);

      return SessionGraphError::OK;
    }
  }

  // Clip not active - return 0 (stopped)
  positionTicks = 0;
  return SessionGraphError::OK;  // Not an error - clip is stopped
}
```

**Audio Thread Changes (Minimal):**

```cpp
// In processAudio(), update currentSample atomically
void TransportController::processAudio(float** outputBuffers, size_t numChannels,
                                       size_t numFrames) {
  // ... render clips

  for (size_t i = 0; i < m_activeClipCount; ++i) {
    ActiveClip& clip = m_activeClips[i];

    // ... read audio

    // ✅ Update position atomically (was non-atomic before)
    int64_t newPosition = clip.currentSample.load(std::memory_order_relaxed) +
                          static_cast<int64_t>(framesRead);
    clip.currentSample.store(newPosition, std::memory_order_release);
  }
}
```

**Performance:**

- **Cost:** 1 atomic load (currentSample) + 1 atomic load (trimInSamples) + integer arithmetic
- **Estimate:** <50 CPU cycles (2 atomic reads + division)
- **Acceptable:** UI thread queries at 30 FPS (33 ms budget) - plenty of headroom

---

### Feature #3: OUT Point & Loop Behavior

**Priority:** P1 (Professional soundboard requirement)
**Effort:** 2-3 hours

#### Requirements

**Current Behavior (BROKEN):**

- Clips stop at trim OUT point ✅
- Loop enabled: Clips seek back to trim IN point ✅
- **BUG:** Fade-out is applied at loop point (WRONG)

**Correct Behavior:**

1. **Loop Disabled:** Clip reaches trim OUT → begin fade-out → continue for `fadeOutSeconds` → stop
2. **Loop Enabled:** Clip reaches trim OUT → **immediate** seek to trim IN (no fade) → continue

**Professional Workflow (SpotOn/QLab Standard):** [2]

```
Example: Music bed with 10s duration, 2s fade-out, loop enabled

Current (BROKEN):
0s      [Fade IN 0→1 over 2s] ────────────── 10s [Fade OUT 1→0 over 2s]
                                            ↓ Loop seeks back
0s      [Fade IN 0→1 over 2s] ...           ❌ CLICK at loop point (fade artifacts)

Correct:
0s      [Fade IN 0→1 over 2s] ────────────── 10s [INSTANT seek, NO FADE]
                                            ↓ Loop seeks back
0s      [Continue at full gain] ...         ✅ SEAMLESS loop (no clicks)
```

#### Implementation

**Data Model Changes (None Required):**

- Loop mode already tracked in `ActiveClip.loopEnabled`
- Fade settings already tracked in `ActiveClip.fadeOutSeconds`, `fadeOutCurve`

**Audio Thread Changes:**

```cpp
// In processAudio() - loop check BEFORE fade processing
void TransportController::processAudio(float** outputBuffers, size_t numChannels,
                                       size_t numFrames) {
  // ... render all clips

  // Update clips (check for loop/stop)
  size_t i = 0;
  while (i < m_activeClipCount) {
    ActiveClip& clip = m_activeClips[i];

    // Check if clip reached trim OUT point
    int64_t clipTrimOut = clip.trimOutSamples.load(std::memory_order_acquire);
    int64_t currentPos = clip.currentSample.load(std::memory_order_acquire);

    if (currentPos >= clipTrimOut) {
      bool shouldLoop = clip.loopEnabled.load(std::memory_order_acquire);

      if (shouldLoop) {
        // ✅ LOOP: Immediate seek to trim IN (NO fade-out)
        int64_t trimIn = clip.trimInSamples.load(std::memory_order_acquire);

        if (clip.audioReader) {
          clip.audioReader->seek(trimIn);  // Seek to start
          clip.currentSample.store(trimIn, std::memory_order_release);  // Update position
        }

        // Post loop callback
        postCallback([this, handle = clip.handle, pos = getCurrentPosition()]() {
          if (m_callback) {
            m_callback->onClipLooped(handle, pos);
          }
        });

        // ✅ Continue playback (don't mark as stopping, don't apply fade)
        ++i;
      } else {
        // ✅ STOP: Begin fade-out at trim OUT point
        clip.isStopping = true;
        clip.fadeOutGain = 1.0f;

        // ✅ DO NOT remove clip yet - fade-out continues for fadeOutSeconds
        // Clip will be removed when fadeOutGain reaches 0.0 (existing logic handles this)
        ++i;
      }
    } else {
      ++i;
    }
  }

  // ... rest of processAudio (fade-out processing for stopping clips)
}
```

**Key Changes:**

1. Loop check happens AFTER rendering (clip has reached trim OUT)
2. Loop mode: Seek back to trim IN, continue playback (no fade-out flag)
3. Stop mode: Set `isStopping = true`, existing fade-out logic applies

**Edge Case: Fade-Out Duration > Clip Duration**

- Current validation: `fadeOutSeconds <= clipDuration` (enforced in `updateClipFades()`)
- Loop behavior: Fade never applied (loop restarts before fade begins) ✅

---

## Medium Priority Features

### Feature #4: Fade-Out Additive Time

**Priority:** P2 (Professional audio standard)
**Effort:** 3-4 hours

#### Requirements

**Current Behavior (PARTIALLY CORRECT):**

- Fade-in: Applied from trim IN (0.0 → 1.0 over `fadeInSeconds`)
- Fade-out: Applied before trim OUT (1.0 → 0.0 over `fadeOutSeconds`)
- **MISSING:** Fade-out "trail" after trim OUT point

**Correct Behavior (SpotOn/QLab Standard):** [2]

```
Example: Clip with trim OUT = 10s, fade-out = 2s

Current (WRONG):
0s ─────────────────────────── 8s [Fade OUT starts] ── 10s [STOP]
                               ↑ Fade-out starts 2s BEFORE trim OUT
                               ❌ Playback ends at trim OUT (no trail)

Correct:
0s ─────────────────────────────────────────────── 10s [Fade OUT starts] ── 12s [STOP]
                                                   ↑ Fade-out starts AT trim OUT
                                                   ✅ Playback continues for fadeOutSeconds
```

**Rationale:**

- **User expectation:** "Trim OUT = last sample of audio content"
- **Fade-out = tail effect:** Allows audio to decay naturally (reverb, sustain)
- **Professional standard:** All DAWs and playback systems work this way [3]

#### Implementation

**Data Model Changes:**

```cpp
// ActiveClip in transport_controller.h
struct ActiveClip {
  // ... existing fields

  // ✅ NEW: Track effective end point (trim OUT + fade-out trail)
  std::atomic<int64_t> effectiveEndSample{0};  // Computed: trimOut + fadeOutSamples

  // ... rest unchanged
};
```

**Computation (Audio Thread):**

```cpp
// In addActiveClip() - compute effective end point
void TransportController::addActiveClip(ClipHandle handle) {
  // ... load metadata

  int64_t trimOut = it->second.trimOutSamples;
  int64_t fadeOutSampleCount = static_cast<int64_t>(fadeOutSeconds * m_sampleRate);

  // ✅ Effective end = trim OUT + fade-out duration
  int64_t effectiveEnd = trimOut + fadeOutSampleCount;

  ActiveClip& clip = m_activeClips[m_activeClipCount++];
  // ... initialize clip

  clip.trimOutSamples.store(trimOut, std::memory_order_release);
  clip.effectiveEndSample.store(effectiveEnd, std::memory_order_release);  // ✅ NEW
  clip.fadeOutSamples.store(fadeOutSampleCount, std::memory_order_release);
}

// In processAudio() - check effectiveEnd instead of trimOut
void TransportController::processAudio(float** outputBuffers, size_t numChannels,
                                       size_t numFrames) {
  // Render each active clip
  for (size_t i = 0; i < m_activeClipCount; ++i) {
    ActiveClip& clip = m_activeClips[i];

    int64_t trimOut = clip.trimOutSamples.load(std::memory_order_acquire);
    int64_t effectiveEnd = clip.effectiveEndSample.load(std::memory_order_acquire);
    int64_t currentPos = clip.currentSample.load(std::memory_order_acquire);

    // ✅ Read audio until EFFECTIVE END (not trim OUT)
    int64_t framesUntilEnd = effectiveEnd - currentPos;
    if (framesUntilEnd <= 0) {
      continue;  // Clip has finished (including fade-out trail)
    }

    size_t framesToRead = static_cast<size_t>(std::min(static_cast<int64_t>(numFrames),
                                                        framesUntilEnd));

    // Read audio from file (may be past trim OUT - file reader handles this)
    auto readResult = clip.audioReader->readSamples(buffer, framesToRead);

    // ... apply fades

    for (size_t frame = 0; frame < framesRead; ++frame) {
      float gain = 1.0f;

      // ... apply clip gain, fade-in

      // ✅ Apply fade-out starting AT trim OUT (not before)
      if (currentPos >= trimOut) {
        int64_t fadeOutRelativePos = currentPos - trimOut;  // Position past trim OUT
        int64_t fadeOutSampleCount = clip.fadeOutSamples.load(std::memory_order_acquire);

        if (fadeOutSampleCount > 0) {
          float fadeOutPos = static_cast<float>(fadeOutRelativePos) /
                             static_cast<float>(fadeOutSampleCount);
          fadeOutPos = std::clamp(fadeOutPos, 0.0f, 1.0f);  // Clamp to [0, 1]

          FadeCurve fadeOutCurveType = clip.fadeOutCurve.load(std::memory_order_acquire);
          gain *= (1.0f - calculateFadeGain(fadeOutPos, fadeOutCurveType));  // 1.0 → 0.0
        }
      }

      // Apply gain to sample
      clipChannelBuffer[frame] = monoSample * gain;
    }
  }

  // Update clips (check for loop/stop)
  size_t i = 0;
  while (i < m_activeClipCount) {
    ActiveClip& clip = m_activeClips[i];

    int64_t effectiveEnd = clip.effectiveEndSample.load(std::memory_order_acquire);
    int64_t currentPos = clip.currentSample.load(std::memory_order_acquire);

    // ✅ Check EFFECTIVE END (trim OUT + fade-out trail)
    if (currentPos >= effectiveEnd) {
      bool shouldLoop = clip.loopEnabled.load(std::memory_order_acquire);

      if (shouldLoop) {
        // Loop: seek back to trim IN
        int64_t trimIn = clip.trimInSamples.load(std::memory_order_acquire);
        clip.audioReader->seek(trimIn);
        clip.currentSample.store(trimIn, std::memory_order_release);

        postCallback([this, handle = clip.handle, pos = getCurrentPosition()]() {
          if (m_callback) {
            m_callback->onClipLooped(handle, pos);
          }
        });

        ++i;
      } else {
        // Stop: clip has finished (including fade-out trail)
        postCallback([this, handle = clip.handle, pos = getCurrentPosition()]() {
          if (m_callback) {
            m_callback->onClipStopped(handle, pos);
          }
        });

        removeActiveClip(clip.handle);
        continue;
      }
    } else {
      ++i;
    }
  }
}
```

**Edge Cases:**

1. **Loop + Fade-Out:** Loop check happens at `effectiveEnd` (after fade-out trail)
   - **Wait, this is WRONG!** Loop should happen at trim OUT, not after fade
   - **Fix:** Loop check at `trimOut`, stop check at `effectiveEnd`

**Corrected Logic:**

```cpp
// In processAudio() - CORRECTED loop/stop check
size_t i = 0;
while (i < m_activeClipCount) {
  ActiveClip& clip = m_activeClips[i];

  int64_t trimOut = clip.trimOutSamples.load(std::memory_order_acquire);
  int64_t effectiveEnd = clip.effectiveEndSample.load(std::memory_order_acquire);
  int64_t currentPos = clip.currentSample.load(std::memory_order_acquire);

  // ✅ LOOP CHECK: At trim OUT (not effective end)
  if (currentPos >= trimOut) {
    bool shouldLoop = clip.loopEnabled.load(std::memory_order_acquire);

    if (shouldLoop) {
      // Loop: seek back to trim IN (immediate, no fade)
      int64_t trimIn = clip.trimInSamples.load(std::memory_order_acquire);
      clip.audioReader->seek(trimIn);
      clip.currentSample.store(trimIn, std::memory_order_release);

      postCallback([this, handle = clip.handle, pos = getCurrentPosition()]() {
        if (m_callback) {
          m_callback->onClipLooped(handle, pos);
        }
      });

      ++i;
      continue;  // ✅ Don't check effectiveEnd (loop restarts before fade)
    }
  }

  // ✅ STOP CHECK: At effective end (trim OUT + fade-out trail)
  if (currentPos >= effectiveEnd) {
    // Clip has finished (including fade-out trail)
    postCallback([this, handle = clip.handle, pos = getCurrentPosition()]() {
      if (m_callback) {
        m_callback->onClipStopped(handle, pos);
      }
    });

    removeActiveClip(clip.handle);
    continue;
  }

  ++i;
}
```

**Testing:**

- Unit test: Clip with trim OUT = 10s, fade-out = 2s → verify audio continues until 12s
- Manual test: Play clip, verify fade-out starts at trim OUT (not before)

---

### Feature #5: "Stop Others On Play" + Crossfade

**Priority:** P2 (Professional soundboard feature)
**Effort:** 2-3 hours

#### Requirements

**Current Behavior:**

- `stopAllClips()` stops all clips simultaneously ✅
- **MISSING:** Crossfade when starting new clip with "Stop Others" enabled

**Correct Behavior (SpotOn/QLab Standard):** [2]

```
Example: Clip A playing, user triggers Clip B with "Stop Others = ON"

Current (NO CROSSFADE):
Time:    0s ──────────────────── 3s (user triggers Clip B)
Clip A:  [Playing at full gain] ──────────────────── [STOP]
Clip B:  [Not playing]          ──────────────────── [START]
         ❌ Abrupt transition (Clip A stops, then Clip B starts)

Correct (CROSSFADE):
Time:    0s ──────────────────── 3s (user triggers Clip B)
Clip A:  [Playing at full gain] [Fade OUT 1.0→0.0 over 2s] ── [STOP at 5s]
Clip B:  [Not playing]          [Fade IN 0.0→1.0 over 2s] ────── [Full gain at 5s]
         ✅ Smooth crossfade (simultaneous fade-out/fade-in)
```

**Professional Workflow:**

- User assigns "Stop Others" property to clip (checkbox in UI)
- When clip starts, all OTHER clips begin fade-out
- New clip begins fade-in
- Fade durations: Use clip's fade-in/fade-out settings (NOT global fade)

#### Implementation

**Data Model Changes:**

```cpp
// AudioFileEntry in transport_controller.h
struct AudioFileEntry {
  // ... existing fields

  bool stopOthersOnPlay = false;  // ✅ NEW: "Stop Others" property
};
```

**Public API:**

```cpp
/// Set "Stop Others On Play" mode for a clip
///
/// @param handle Clip handle (must be registered)
/// @param stopOthers true = stop all other clips when this clip starts, false = normal
/// @return SessionGraphError::OK on success, error code on failure
///
/// Thread-safe: Can be called from UI thread
/// Takes effect: On next clip start
///
/// Behavior (stopOthers = true):
/// - When clip starts, all OTHER clips begin fade-out (using their fadeOutSeconds setting)
/// - This clip begins fade-in (using its fadeInSeconds setting)
/// - Result: Professional crossfade (simultaneous fade-out/fade-in)
///
/// Use Cases:
/// - Music beds (only one playing at a time)
/// - Dialog replacement (stop previous take)
/// - Announcement interruption (stop background music)
virtual SessionGraphError setClipStopOthersMode(ClipHandle handle, bool stopOthers) = 0;
```

**Implementation:**

```cpp
// In startClip() - check "Stop Others" property BEFORE posting command
SessionGraphError TransportController::startClip(ClipHandle handle) {
  if (handle == 0) {
    return SessionGraphError::InvalidHandle;
  }

  // Check if already playing
  if (isClipPlaying(handle)) {
    return SessionGraphError::OK;  // Already playing, no-op
  }

  // ✅ Check if this clip has "Stop Others" enabled
  bool shouldStopOthers = false;
  {
    std::lock_guard<std::mutex> lock(m_audioFilesMutex);
    auto it = m_audioFiles.find(handle);
    if (it != m_audioFiles.end()) {
      shouldStopOthers = it->second.stopOthersOnPlay;
    }
  }

  // ✅ If "Stop Others" enabled, stop all OTHER clips (with fade-out)
  if (shouldStopOthers) {
    // Post StopAll command FIRST (audio thread will begin fade-out)
    size_t writeIndex = m_commandWriteIndex.load(std::memory_order_relaxed);
    size_t nextIndex = (writeIndex + 1) % MAX_COMMANDS;

    if (nextIndex != m_commandReadIndex.load(std::memory_order_acquire)) {
      m_commands[writeIndex] = {TransportCommand::Type::StopAll, 0, 0};
      m_commandWriteIndex.store(nextIndex, std::memory_order_release);
    }

    // Small delay to ensure StopAll command is processed before Start
    // (Audio thread processes commands sequentially, so order is guaranteed)
  }

  // Post Start command (clip will begin fade-in)
  size_t writeIndex = m_commandWriteIndex.load(std::memory_order_relaxed);
  size_t nextIndex = (writeIndex + 1) % MAX_COMMANDS;

  if (nextIndex == m_commandReadIndex.load(std::memory_order_acquire)) {
    return SessionGraphError::InternalError;  // Queue full
  }

  m_commands[writeIndex] = {TransportCommand::Type::Start, handle, 0};
  m_commandWriteIndex.store(nextIndex, std::memory_order_release);

  return SessionGraphError::OK;
}

// In processCommands() - StopAll sets isStopping (existing logic handles fade-out)
void TransportController::processCommands() {
  size_t readIndex = m_commandReadIndex.load(std::memory_order_relaxed);
  size_t writeIndex = m_commandWriteIndex.load(std::memory_order_acquire);

  while (readIndex != writeIndex) {
    const TransportCommand& cmd = m_commands[readIndex];

    switch (cmd.type) {
    case TransportCommand::Type::Start:
      addActiveClip(cmd.handle);  // New clip begins fade-in
      postCallback([this, handle = cmd.handle, pos = getCurrentPosition()]() {
        if (m_callback) {
          m_callback->onClipStarted(handle, pos);
        }
      });
      break;

    case TransportCommand::Type::StopAll:
      // ✅ All clips begin fade-out (existing logic)
      for (size_t i = 0; i < m_activeClipCount; ++i) {
        m_activeClips[i].isStopping = true;
        m_activeClips[i].fadeOutGain = 1.0f;
      }
      break;

    // ... rest of command handling
    }

    readIndex = (readIndex + 1) % MAX_COMMANDS;
    m_commandReadIndex.store(readIndex, std::memory_order_release);
  }
}
```

**Key Points:**

1. **Command order:** `StopAll` → `Start` (sequential processing guarantees crossfade timing)
2. **Fade durations:** Each clip uses its own fade-in/fade-out settings (not global)
3. **Existing logic:** Fade-out for stopping clips already implemented (just set `isStopping = true`)

**Edge Case: Stop Others + Loop**

- New clip with "Stop Others = ON" starts
- All other clips begin fade-out (including looping clips)
- Looping clips: `isStopping = true` overrides loop mode (clip stops after fade)

**Testing:**

- Unit test: Start clip with "Stop Others = ON" → verify all other clips begin fade-out
- Manual test: Play music bed, trigger announcement → verify smooth crossfade

---

## Low Priority Features

### Feature #6: Batch Metadata Update/Query APIs

**Priority:** P3 (Performance optimization)
**Effort:** 1-2 hours

#### Requirements

**Current API (Inefficient for Bulk Updates):**

```cpp
// Update metadata for 384 clips (8 tabs × 48 buttons)
for (int i = 0; i < 384; ++i) {
  transport->updateClipGain(clip_handles[i], gains[i]);      // 384 mutex locks
  transport->updateClipTrimPoints(clip_handles[i], in, out); // 384 mutex locks
  transport->setClipLoopMode(clip_handles[i], loops[i]);     // 384 mutex locks
}
// Total: 1152 mutex locks (inefficient)
```

**Proposed API (Batch Update):**

```cpp
/// Update metadata for multiple clips in a single call
///
/// @param updates Array of metadata updates
/// @param count Number of updates
/// @return SessionGraphError::OK on success, error code on failure
///
/// Thread-safe: Can be called from UI thread
/// Performance: Single mutex lock for all updates (vs N locks for N clips)
///
/// Use Cases:
/// - Session load (restore metadata for all clips)
/// - Bulk edit (apply gain change to multiple clips)
/// - Undo/redo (restore previous state)
struct ClipMetadataUpdate {
  ClipHandle handle;

  // Optional fields (set field, then set corresponding flag)
  int64_t trimInSamples;
  int64_t trimOutSamples;
  double fadeInSeconds;
  double fadeOutSeconds;
  FadeCurve fadeInCurve;
  FadeCurve fadeOutCurve;
  float gainDb;
  bool loopEnabled;
  bool stopOthersOnPlay;

  // Flags (which fields to update)
  bool updateTrim : 1;
  bool updateFades : 1;
  bool updateGain : 1;
  bool updateLoop : 1;
  bool updateStopOthers : 1;
};

virtual SessionGraphError updateClipMetadata(const ClipMetadataUpdate* updates,
                                             size_t count) = 0;
```

**Query API (Batch Read):**

```cpp
/// Get metadata for multiple clips in a single call
///
/// @param handles Array of clip handles
/// @param[out] metadata Array of metadata structs (preallocated by caller)
/// @param count Number of clips to query
/// @return SessionGraphError::OK on success, error code on failure
///
/// Thread-safe: Can be called from any thread
/// Performance: Single mutex lock for all queries (vs N locks for N clips)
struct ClipMetadata {
  ClipHandle handle;

  // All metadata fields
  int64_t trimInSamples;
  int64_t trimOutSamples;
  double fadeInSeconds;
  double fadeOutSeconds;
  FadeCurve fadeInCurve;
  FadeCurve fadeOutCurve;
  float gainDb;
  bool loopEnabled;
  bool stopOthersOnPlay;

  // Audio file metadata
  int64_t fileDurationSamples;
  uint16_t numChannels;
  uint32_t sampleRate;
};

virtual SessionGraphError getClipMetadata(const ClipHandle* handles,
                                          ClipMetadata* metadata,
                                          size_t count) const = 0;
```

#### Implementation

**Batch Update:**

```cpp
SessionGraphError TransportController::updateClipMetadata(const ClipMetadataUpdate* updates,
                                                          size_t count) {
  if (!updates || count == 0) {
    return SessionGraphError::InvalidParameter;
  }

  // ✅ Single mutex lock for ALL updates (efficient)
  std::lock_guard<std::mutex> lock(m_audioFilesMutex);

  for (size_t i = 0; i < count; ++i) {
    const ClipMetadataUpdate& update = updates[i];

    if (update.handle == 0) {
      continue;  // Skip invalid handles
    }

    auto it = m_audioFiles.find(update.handle);
    if (it == m_audioFiles.end()) {
      continue;  // Skip unregistered clips
    }

    AudioFileEntry& entry = it->second;

    // Update fields based on flags
    if (update.updateTrim) {
      entry.trimInSamples = update.trimInSamples;
      entry.trimOutSamples = update.trimOutSamples;
    }

    if (update.updateFades) {
      entry.fadeInSeconds = update.fadeInSeconds;
      entry.fadeOutSeconds = update.fadeOutSeconds;
      entry.fadeInCurve = update.fadeInCurve;
      entry.fadeOutCurve = update.fadeOutCurve;
    }

    if (update.updateGain) {
      entry.gainDb = update.gainDb;
    }

    if (update.updateLoop) {
      entry.loopEnabled = update.loopEnabled;
    }

    if (update.updateStopOthers) {
      entry.stopOthersOnPlay = update.stopOthersOnPlay;
    }
  }

  // ✅ Update active clips (outside mutex lock to avoid deadlock)
  // NOTE: This is a simplification - production code should update active clips atomically

  return SessionGraphError::OK;
}
```

**Batch Query:**

```cpp
SessionGraphError TransportController::getClipMetadata(const ClipHandle* handles,
                                                       ClipMetadata* metadata,
                                                       size_t count) const {
  if (!handles || !metadata || count == 0) {
    return SessionGraphError::InvalidParameter;
  }

  // ✅ Single mutex lock for ALL queries (efficient)
  std::lock_guard<std::mutex> lock(const_cast<std::mutex&>(m_audioFilesMutex));

  for (size_t i = 0; i < count; ++i) {
    ClipHandle handle = handles[i];

    if (handle == 0) {
      continue;  // Skip invalid handles
    }

    auto it = m_audioFiles.find(handle);
    if (it == m_audioFiles.end()) {
      continue;  // Skip unregistered clips
    }

    const AudioFileEntry& entry = it->second;

    // Copy metadata to output
    metadata[i].handle = handle;
    metadata[i].trimInSamples = entry.trimInSamples;
    metadata[i].trimOutSamples = entry.trimOutSamples;
    metadata[i].fadeInSeconds = entry.fadeInSeconds;
    metadata[i].fadeOutSeconds = entry.fadeOutSeconds;
    metadata[i].fadeInCurve = entry.fadeInCurve;
    metadata[i].fadeOutCurve = entry.fadeOutCurve;
    metadata[i].gainDb = entry.gainDb;
    metadata[i].loopEnabled = entry.loopEnabled;
    metadata[i].stopOthersOnPlay = entry.stopOthersOnPlay;

    // Audio file metadata
    metadata[i].fileDurationSamples = entry.metadata.duration_samples;
    metadata[i].numChannels = entry.metadata.num_channels;
    metadata[i].sampleRate = entry.metadata.sample_rate;
  }

  return SessionGraphError::OK;
}
```

**Performance:**

- **Before:** 384 clips × 3 metadata calls = 1152 mutex locks
- **After:** 1 batch call = 1 mutex lock
- **Speedup:** ~1000× reduction in lock contention

---

## Technical Approach

### Broadcast-Safe Constraints

**All implementations must satisfy:**

1. **No allocations in audio thread**
   - Use pre-allocated buffers
   - Use fixed-size arrays (MAX_ACTIVE_CLIPS = 32)
   - Use lock-free structures (std::atomic, lock-free queue)

2. **No locks in audio thread**
   - Exception: `std::shared_ptr` atomic ref counting (acceptable)
   - Metadata updates: Atomic operations only (std::atomic<T>)
   - Command queue: Lock-free SPSC queue

3. **No I/O in audio thread**
   - No file operations (except AudioFileReader::readSamples, which is buffered)
   - No network calls
   - No printf/logging (exception: temporary diagnostics, removed before release)

4. **Sample-accurate timing**
   - Use 64-bit sample counts (not floating-point seconds)
   - Position tracking: Atomic int64_t (deterministic)
   - Fade calculations: Computed per-frame (not per-buffer)

### Data Structure Changes

**Summary of Changes:**

| Structure        | Field Changes                                                     | Rationale                         |
| ---------------- | ----------------------------------------------------------------- | --------------------------------- |
| AudioFileEntry   | `unique_ptr` → `shared_ptr<IAudioFileReader>` (line 157)          | Fix heap-use-after-free           |
|                  | `bool stopOthersOnPlay` (new field)                               | "Stop Others" feature             |
| ActiveClip       | `std::atomic<int64_t> currentSample` (was non-atomic)             | Thread-safe position tracking     |
|                  | `std::shared_ptr<IAudioFileReader> audioReader` (was raw pointer) | Fix heap-use-after-free           |
|                  | `std::atomic<int64_t> effectiveEndSample` (new field)             | Fade-out additive time            |
| Public API       | `getClipPosition(handle, positionTicks)` (new method)             | Position tracking API             |
|                  | `setClipStopOthersMode(handle, stopOthers)` (new method)          | "Stop Others" API                 |
|                  | `updateClipMetadata(updates, count)` (new method)                 | Batch metadata update             |
|                  | `getClipMetadata(handles, metadata, count)` (new method)          | Batch metadata query              |
| ClipMetadata     | New struct for batch queries                                      | Efficient bulk metadata access    |
| TransportCommand | (No changes)                                                      | Existing command queue sufficient |

---

## Implementation Plan

### Phase 1: Critical Safety Fix (2-3 hours) ⚠️ BLOCKER

**Tasks:**

1. **Change `AudioFileEntry.reader` to `shared_ptr`** (5 min)
   - File: `src/core/transport/transport_controller.h:157`
   - Change: `std::unique_ptr<IAudioFileReader>` → `std::shared_ptr<IAudioFileReader>`

2. **Change `ActiveClip.audioReader` to `shared_ptr`** (5 min)
   - File: `src/core/transport/transport_controller.h:59`
   - Change: `IAudioFileReader*` → `std::shared_ptr<IAudioFileReader>`

3. **Update `registerClipAudio()` to use `shared_ptr`** (10 min)
   - File: `src/core/transport/transport_controller.cpp:276-303`
   - Change: `auto reader = createAudioFileReader()` → `auto reader = std::make_shared<AudioFileReaderImpl>()`
   - Change: `entry.reader = std::move(reader)` → `entry.reader = reader`

4. **Update `addActiveClip()` to use `shared_ptr`** (10 min)
   - File: `src/core/transport/transport_controller.cpp:119-218`
   - Change: `IAudioFileReader* reader = nullptr` → `std::shared_ptr<IAudioFileReader> reader`
   - Change: `reader = it->second.reader.get()` → `reader = it->second.reader`
   - Change: `clip.audioReader = reader` → `clip.audioReader = reader` (copy shared_ptr)

5. **Update `removeActiveClip()` to reset `shared_ptr`** (10 min)
   - File: `src/core/transport/transport_controller.cpp:220-260`
   - Change: Field-by-field copy to include `dest.audioReader = src.audioReader` (copy shared_ptr)

6. **Update `processAudio()` null checks** (5 min)
   - File: `src/core/transport/transport_controller.cpp:225`
   - Change: `if (!clip.audioReader || !clip.audioReader->isOpen())` (no change, works with shared_ptr)

7. **Compile and test** (1-2 hours)
   - Build with AddressSanitizer: `cmake -DCMAKE_CXX_FLAGS="-fsanitize=address"`
   - Run OCC with 100 tab switches during playback
   - Verify NO heap-use-after-free errors
   - Verify NO performance regression (profile with 32 active clips)

**Validation:**

```bash
# Build with AddressSanitizer
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_FLAGS="-fsanitize=address -g"
cmake --build build --target orpheus_clip_composer_app

# Run stress test (automated)
./tests/occ_tab_switch_stress_test.sh  # 100 tab switches, 16 clips playing

# Expected: NO AddressSanitizer errors
# Success criteria: "All tests passed, no crashes, no leaks"
```

---

### Phase 2: Position Tracking API (1 hour)

**Tasks:**

1. **Make `ActiveClip.currentSample` atomic** (5 min)
   - File: `src/core/transport/transport_controller.h:35`
   - Change: `int64_t currentSample` → `std::atomic<int64_t> currentSample{0}`

2. **Update `processAudio()` to use atomic store** (10 min)
   - File: `src/core/transport/transport_controller.cpp:310`
   - Change: `clip.currentSample += framesRead` → `clip.currentSample.store(newPos, std::memory_order_release)`

3. **Add `getClipPosition()` to public API** (10 min)
   - File: `include/orpheus/transport_controller.h` (after line 263)
   - Add method declaration with Doxygen comments

4. **Implement `getClipPosition()`** (20 min)
   - File: `src/core/transport/transport_controller.cpp` (after line 528)
   - Implement method (see "Feature #2" above for full code)

5. **Write unit test** (15 min)
   - File: `tests/transport/position_tracking_test.cpp` (new)
   - Test cases:
     - Start clip → query position → verify increasing
     - Stop clip → query position → verify 0
     - Clip not active → query position → verify 0
     - Query 1000× in loop → verify <100 CPU cycles per call (performance)

6. **Compile and test** (10 min)
   - Build and run unit test
   - Verify thread-safe (ThreadSanitizer clean)

---

### Phase 3: OUT Point Enforcement (2-3 hours)

**Tasks:**

1. **Review existing loop logic** (10 min)
   - File: `src/core/transport/transport_controller.cpp:423-458`
   - Current logic: Loop check at trim OUT, but fade-out may be applied incorrectly

2. **Fix loop + fade interaction** (20 min)
   - Ensure loop check happens BEFORE fade-out check
   - Ensure fade-out is NOT applied when loop is enabled

3. **Add `effectiveEndSample` to `ActiveClip`** (10 min)
   - File: `src/core/transport/transport_controller.h:40`
   - Add field: `std::atomic<int64_t> effectiveEndSample{0}`

4. **Compute `effectiveEndSample` in `addActiveClip()`** (15 min)
   - File: `src/core/transport/transport_controller.cpp:119-218`
   - Compute: `effectiveEnd = trimOut + fadeOutSamples`
   - Store: `clip.effectiveEndSample.store(effectiveEnd, std::memory_order_release)`

5. **Update `processAudio()` loop check** (30 min)
   - File: `src/core/transport/transport_controller.cpp:401-464`
   - Split logic:
     - Loop check at `trimOut` (immediate seek, no fade)
     - Stop check at `effectiveEnd` (after fade-out trail)

6. **Write unit tests** (45 min)
   - File: `tests/transport/out_point_test.cpp` (new)
   - Test cases:
     - Loop enabled: Clip restarts at trim OUT (no fade)
     - Loop disabled: Clip stops at effective end (trim OUT + fade-out)
     - Loop + fade-out: Verify fade NOT applied at loop point
     - Fade-out additive time: Verify audio continues past trim OUT

7. **Compile and test** (30 min)
   - Build and run unit tests
   - Manual test with OCC: Enable loop, verify seamless loop

---

### Phase 4: Fade Semantics (3-4 hours)

**Tasks:**

1. **Update fade-out calculation** (30 min)
   - File: `src/core/transport/transport_controller.cpp:342-348`
   - Change fade-out start: From `trimOut - fadeOutSamples` to `trimOut`
   - Apply fade-out for samples AFTER trim OUT

2. **Extend read range to `effectiveEnd`** (20 min)
   - File: `src/core/transport/transport_controller.cpp:243-249`
   - Change: `framesUntilEnd = trimOut - currentPos` → `framesUntilEnd = effectiveEnd - currentPos`

3. **Handle "Stop Others On Play"** (1 hour)
   - Add `stopOthersOnPlay` field to `AudioFileEntry` (5 min)
   - Add `setClipStopOthersMode()` to public API (10 min)
   - Implement `setClipStopOthersMode()` (10 min)
   - Update `startClip()` to check flag and post `StopAll` command (20 min)
   - Test crossfade behavior (15 min)

4. **Write unit tests** (1 hour)
   - File: `tests/transport/fade_semantics_test.cpp` (new)
   - Test cases:
     - Fade-out additive time: Verify audio continues past trim OUT
     - Stop Others: Start clip → verify all others begin fade-out
     - Crossfade: Verify simultaneous fade-out/fade-in

5. **Compile and test** (1 hour)
   - Build and run unit tests
   - Manual test with OCC: Verify crossfade sounds smooth

---

### Phase 5: Batch Metadata APIs (1-2 hours) ⏸️ OPTIONAL

**Tasks:**

1. **Define `ClipMetadataUpdate` struct** (10 min)
   - File: `include/orpheus/transport_controller.h` (before ITransportController)
   - Define struct with all metadata fields + flags

2. **Define `ClipMetadata` struct** (10 min)
   - File: `include/orpheus/transport_controller.h` (before ITransportController)
   - Define struct for query results

3. **Add APIs to public interface** (10 min)
   - `updateClipMetadata(updates, count)`
   - `getClipMetadata(handles, metadata, count)`

4. **Implement `updateClipMetadata()`** (30 min)
   - File: `src/core/transport/transport_controller.cpp` (after line 528)
   - Single mutex lock for all updates

5. **Implement `getClipMetadata()`** (30 min)
   - File: `src/core/transport/transport_controller.cpp` (after line 528)
   - Single mutex lock for all queries

6. **Write unit tests** (30 min)
   - File: `tests/transport/batch_metadata_test.cpp` (new)
   - Test cases:
     - Update 100 clips → verify all updated
     - Query 100 clips → verify correct metadata
     - Performance: Verify <1ms for 384 clips

7. **Compile and test** (10 min)

**Note:** This phase is OPTIONAL (P3 priority). Defer if time is limited.

---

## Testing Strategy

### Unit Tests (New Files)

**Test Coverage:**

| Test File                    | Test Cases | LOC      | Priority |
| ---------------------------- | ---------- | -------- | -------- |
| `position_tracking_test.cpp` | 5          | ~150     | P1       |
| `out_point_test.cpp`         | 6          | ~200     | P1       |
| `fade_semantics_test.cpp`    | 8          | ~250     | P2       |
| `batch_metadata_test.cpp`    | 4          | ~150     | P3       |
| **Total**                    | **23**     | **~750** |          |

**Test Execution:**

```bash
# Build with sanitizers
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug \
  -DCMAKE_CXX_FLAGS="-fsanitize=address -fsanitize=thread -g"
cmake --build build

# Run all transport tests
ctest --test-dir build -R "transport|position|out_point|fade_semantics|batch_metadata" \
  --output-on-failure

# Run with ThreadSanitizer
TSAN_OPTIONS="second_deadlock_stack=1" ctest --test-dir build -R "transport" \
  --output-on-failure
```

### Integration Tests (Existing + New)

**Test Scenarios:**

1. **Tab Switch Stress Test** (NEW)
   - Load 16 clips, start all
   - Switch tabs 100 times during playback
   - Verify NO crashes, NO AddressSanitizer errors
   - Verify audio continues uninterrupted

2. **Position Tracking Accuracy** (NEW)
   - Start clip, query position every 10ms
   - Verify position increases monotonically
   - Verify position matches expected value (±1 tick tolerance)

3. **Loop + Fade Interaction** (NEW)
   - Enable loop, set fade-out = 2s
   - Verify clip loops at trim OUT (not after fade-out)
   - Verify NO audio clicks at loop point

4. **Stop Others Crossfade** (NEW)
   - Play music bed, trigger announcement with "Stop Others = ON"
   - Record output to WAV, analyze with FFT
   - Verify smooth crossfade (no abrupt transitions, no clicks)

### Manual Testing (OCC)

**Test Checklist:**

- [ ] **Safety:** Switch tabs 20 times during playback → NO crashes
- [ ] **Position:** Open Edit Dialog → verify waveform playhead moves smoothly
- [ ] **Loop:** Enable loop for music bed → verify seamless looping
- [ ] **Fade-out:** Set fade-out = 3s → verify audio continues 3s past trim OUT
- [ ] **Stop Others:** Trigger clip with "Stop Others = ON" → verify crossfade

---

## Acceptance Criteria

### CRITICAL Priority (Must Pass Before Merge)

- [ ] **Heap-use-after-free eliminated**
  - AddressSanitizer clean (no errors after 100 tab switches)
  - ThreadSanitizer clean (no race conditions)
  - Stress test: 16 clips playing, 100 tab switches, 0 crashes

- [ ] **Performance acceptable**
  - `std::shared_ptr` overhead: <5% CPU increase (measure with profiler)
  - 32 active clips: CPU usage <20% (M1 Pro @ 48kHz, 512 samples)

### HIGH Priority (Requires Testing)

- [ ] **Position tracking functional**
  - `getClipPosition()` returns correct position (±1 tick tolerance)
  - Thread-safe: UI thread queries while audio thread runs (no data races)
  - Performance: <100 CPU cycles per call

- [ ] **OUT point enforcement correct**
  - Loop enabled: Clip restarts at trim IN (no fade applied)
  - Loop disabled: Clip stops at effective end (trim OUT + fade-out)
  - No audio clicks at loop point (FFT analysis: <-60dB)

### MEDIUM Priority (Functional Requirements)

- [ ] **Fade-out additive time working**
  - Clip with fade-out = 2s continues 2s past trim OUT
  - Fade-out starts at trim OUT (not before)

- [ ] **Stop Others crossfade working**
  - Start clip with "Stop Others = ON" → all others begin fade-out
  - Simultaneous fade-out/fade-in (smooth crossfade)

### LOW Priority (Optional)

- [ ] **Batch metadata APIs implemented**
  - `updateClipMetadata()` updates multiple clips in single call
  - `getClipMetadata()` queries multiple clips in single call
  - Performance: <1ms for 384 clips

---

## Risks & Mitigations

### Risk 1: `shared_ptr` Performance Overhead

**Probability:** Medium
**Impact:** HIGH (audio dropouts if overhead is significant)

**Mitigation:**

- Profile with 32 active clips (worst-case scenario)
- Measure atomic ref count overhead with CPU profiler
- Fallback: Custom lock-free ref counting (if `shared_ptr` too slow)
- Acceptance: <5% CPU increase (negligible for broadcast use)

### Risk 2: Fade-Out Additive Time Complexity

**Probability:** Low
**Impact:** MEDIUM (implementation may be more complex than expected)

**Mitigation:**

- Start with simple implementation (add `effectiveEndSample` field)
- Test with edge cases (fade-out > clip duration)
- Defer to Phase 4 if Phase 3 takes longer than expected

### Risk 3: Position Tracking Accuracy

**Probability:** Low
**Impact:** MEDIUM (waveform playhead may be jerky)

**Mitigation:**

- Use atomic operations (guarantee correct value)
- Test with 30 FPS updates (typical UI refresh rate)
- Verify ±1 tick tolerance (acceptable for visual feedback)

### Risk 4: Testing Time Overrun

**Probability:** Medium
**Impact:** MEDIUM (sprint extends beyond 2 days)

**Mitigation:**

- Prioritize CRITICAL and HIGH priority features
- Defer LOW priority (batch APIs) if time runs out
- Automated tests run in CI (parallel execution)

---

## Success Metrics

### Quantitative Metrics

| Metric                      | Target                      | Measurement Method              |
| --------------------------- | --------------------------- | ------------------------------- |
| Heap-use-after-free crashes | 0 errors (100 tab switches) | AddressSanitizer report         |
| Position tracking accuracy  | ±1 tick (±13.33 ms)         | Unit test comparison            |
| Loop click-free             | <-60dB at loop point        | FFT analysis of recorded output |
| CPU overhead (shared_ptr)   | <5% increase                | Instruments profiler (macOS)    |
| Test coverage               | 23 new test cases passing   | ctest report                    |
| Manual testing              | 5/5 scenarios pass          | Checklist completion            |

### Qualitative Metrics

- [ ] **User Experience:** OCC users can switch tabs during playback without interruption
- [ ] **Developer Experience:** SDK APIs are well-documented and easy to use
- [ ] **Code Quality:** All code passes clang-format, no compiler warnings
- [ ] **Broadcast-Safe:** No allocations, locks, or I/O in audio thread (verified by code review)

---

## Files Modified Summary

### C++ Core SDK (10 files)

| File                                                    | Changes                                     | LOC Added | LOC Modified |
| ------------------------------------------------------- | ------------------------------------------- | --------- | ------------ |
| `include/orpheus/transport_controller.h`                | Add 3 new API methods, ClipMetadata structs | +150      | +20          |
| `src/core/transport/transport_controller.h`             | Change AudioFileEntry, ActiveClip structs   | +10       | +30          |
| `src/core/transport/transport_controller.cpp`           | Implement all new features                  | +400      | +150         |
| `tests/transport/position_tracking_test.cpp`            | New unit tests                              | +150      | 0            |
| `tests/transport/out_point_test.cpp`                    | New unit tests                              | +200      | 0            |
| `tests/transport/fade_semantics_test.cpp`               | New unit tests                              | +250      | 0            |
| `tests/transport/batch_metadata_test.cpp` (optional)    | New unit tests                              | +150      | 0            |
| `tests/transport/CMakeLists.txt`                        | Register new test targets                   | +10       | 0            |
| `tests/integration/occ_tab_switch_stress_test.sh` (new) | Tab switch stress test script               | +80       | 0            |
| **Total**                                               |                                             | **~1400** | **~200**     |

### Documentation (1 file)

| File                 | Changes          | LOC Added |
| -------------------- | ---------------- | --------- |
| `docs/ORP/ORP084.md` | This sprint plan | +1800     |

### Total Lines Changed

- **Code:** ~1600 lines (1400 added + 200 modified)
- **Documentation:** ~1800 lines
- **Total:** ~3400 lines

---

## Timeline

### Day 1 (8 hours)

**Morning (4 hours):**

- Phase 1: Critical Safety Fix (2-3 hours)
  - Implement `shared_ptr` changes
  - Build with AddressSanitizer
  - Run stress test (100 tab switches)
- Phase 2: Position Tracking API (1 hour)
  - Make `currentSample` atomic
  - Implement `getClipPosition()`
  - Write unit test

**Afternoon (4 hours):**

- Phase 3: OUT Point Enforcement (2-3 hours)
  - Add `effectiveEndSample` field
  - Fix loop + fade interaction
  - Write unit tests
- Begin Phase 4: Fade Semantics (1 hour)
  - Update fade-out calculation
  - Extend read range to `effectiveEnd`

**End of Day 1:**

- CRITICAL and HIGH priority features 80% complete
- All CRITICAL tests passing (heap-use-after-free eliminated)

### Day 2 (8 hours)

**Morning (4 hours):**

- Complete Phase 4: Fade Semantics (3 hours)
  - Implement "Stop Others On Play"
  - Write unit tests
  - Manual testing with OCC
- Buffer time (1 hour)
  - Fix any issues from testing
  - Address code review feedback

**Afternoon (4 hours):**

- Phase 5: Batch Metadata APIs (1-2 hours) ⏸️ OPTIONAL
  - Implement if time permits
  - Otherwise defer to future sprint
- Final testing (2 hours)
  - Run full test suite with sanitizers
  - Manual testing with OCC (all scenarios)
  - Performance profiling (32 clips)
- Documentation (1 hour)
  - Update CLAUDE.md with new APIs
  - Write completion report (ORP084_COMPLETION.md)

**End of Day 2:**

- All CRITICAL and HIGH priority features complete
- All tests passing
- Documentation updated
- Ready for code review and merge

---

## References

[1] SMPTE Timecode Standards - Society of Motion Picture and Television Engineers. https://www.smpte.org/

[2] QLab 5 User Manual - Cue Playback and Crossfades. Figure 53 LLC. https://qlab.app/docs/v5/

[3] SpotOn! User Guide - Professional Soundboard Software. Richmond Sound Design. https://richmondsounddesign.com/

---

**Document Status:** Authoritative
**Next Review:** After Phase 1 completion (safety fix verification)
**Maintained By:** SDK Core Team
**Last Updated:** 2025-10-26
