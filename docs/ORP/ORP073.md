# CoreAudio Sample Rate Mismatch Fix

**Date:** 2025-10-13
**Status:** ✅ Resolved
**Severity:** Critical
**Affected Component:** `src/platform/audio_drivers/coreaudio/coreaudio_driver.cpp`

## Summary

Fixed critical audio playback issue where CoreAudio device sample rate mismatch caused audio to play 8.8% too slow and sound distorted. The macOS audio device was running at 44.1kHz while the SDK was generating audio at 48kHz, causing timing drift and quality degradation.

## Problem Description

### Symptoms

- Audio playback too slow (~8.8% slower than expected)
- Distorted/degraded audio quality
- User report: "crackling/popping/pitches and timbres are all fucked up. digitally broken"

### Root Cause

The CoreAudio driver was setting the AudioUnit's stream format to 48kHz, but **not** setting the underlying hardware device's nominal sample rate. macOS audio devices default to 44.1kHz, so the hardware was playing back 48kHz-rate audio at 44.1kHz speed.

**Speed ratio:** 48000 / 44100 = 1.088435 (8.8% slower)

### Diagnosis Process

1. Added diagnostics to verify sample rates at multiple levels
2. Discovered mismatch between AudioUnit format (48kHz) and device nominal rate (44.1kHz)
3. Identified that `AudioUnitSetProperty` sets format but doesn't change device hardware rate

## Solution

### Code Changes

**File:** `src/platform/audio_drivers/coreaudio/coreaudio_driver.cpp:347-364`

Added device sample rate configuration BEFORE setting AudioUnit stream format:

```cpp
// CRITICAL FIX: Set the DEVICE's nominal sample rate to match our requested rate
// This must be done BEFORE setting the AudioUnit's stream format
Float64 requestedSampleRate = static_cast<Float64>(config_.sample_rate);
AudioObjectPropertyAddress deviceSRAddr = {
  kAudioDevicePropertyNominalSampleRate,
  kAudioObjectPropertyScopeGlobal,
  kAudioObjectPropertyElementMain
};
status = AudioObjectSetPropertyData(device_id, &deviceSRAddr, 0, nullptr,
                                   sizeof(Float64), &requestedSampleRate);
if (status != noErr) {
  FILE* diagFile = fopen("/tmp/coreaudio_init.log", "a");
  if (diagFile) {
    fprintf(diagFile, "CoreAudio: WARNING - Failed to set device sample rate (status: %d)\n", (int)status);
    fclose(diagFile);
  }
  // Don't fail completely, but this will cause playback speed issues
}
```

### Why This Works

1. **AudioUnit stream format** tells CoreAudio what format we're providing (48kHz float32)
2. **Device nominal sample rate** tells the hardware what rate to actually run at
3. These must match, or the hardware will resample incorrectly

The fix ensures the hardware device runs at the same rate we're generating audio.

## Verification

### Diagnostic Output (Before Fix)

```
CoreAudio: Requested sample rate: 48000 Hz
CoreAudio: AudioUnit sample rate: 48000.0 Hz
CoreAudio: DEVICE nominal sample rate: 44100.0 Hz
CoreAudio: ***CRITICAL*** DEVICE RATE MISMATCH! Ratio: 1.088435 (this causes slow playback!)
```

### Diagnostic Output (After Fix)

```
CoreAudio: Requested sample rate: 48000 Hz
CoreAudio: AudioUnit sample rate: 48000.0 Hz
CoreAudio: DEVICE nominal sample rate: 48000.0 Hz
```

### User Confirmation

Audio playback now works perfectly at correct speed with no distortion.

## Lessons Learned

### For CoreAudio Development

1. **Always set device nominal sample rate** - Setting AudioUnit format is not enough
2. **Device rate must match AudioUnit format** - Mismatches cause resampling issues
3. **macOS defaults to 44.1kHz** - Professional audio apps typically need 48kHz
4. **Set device rate BEFORE AudioUnit format** - Order matters in initialization

### For SDK Audio Drivers

1. **Multi-level verification required** - Check both format and device rates
2. **Diagnostic logging is essential** - File-based logging works when stdout doesn't
3. **Sample rate mismatches manifest as speed issues** - Not just quality degradation
4. **Platform audio systems have multiple configuration layers** - Must configure all layers

### For Future Driver Development

1. **Document initialization order** - Device properties before unit properties
2. **Add verification in initialization** - Query actual rates after setting
3. **Fail explicitly on mismatches** - Don't silently proceed with wrong rate
4. **Consider user's system settings** - Audio MIDI Setup.app can override

## Implementation Notes

### Related Files Modified

- `src/platform/audio_drivers/coreaudio/coreaudio_driver.cpp` (lines 347-364, 397-427)

### Diagnostic Code Added

- Device nominal sample rate query and comparison
- Initialization logging to `/tmp/coreaudio_init.log`
- Mismatch warnings with exact ratio calculation

### Not Changed

- AudioUnit stream format configuration (already correct)
- Buffer size handling (separate concern)
- Channel configuration (working as expected)

## Testing

### Test Environment

- **Platform:** macOS 14.6 (Darwin 24.6.0)
- **Hardware:** Default audio output device
- **Sample Files:** 48kHz, 16-bit, stereo WAV files
- **Application:** Orpheus Clip Composer (OCC) MVP

### Test Results

- ✅ Audio plays at correct speed
- ✅ No distortion or quality degradation
- ✅ Multiple simultaneous clips work correctly
- ✅ Sample rate mismatch no longer occurs
- ✅ Device successfully switches to 48kHz

## API Reference

### CoreAudio APIs Used

**`AudioObjectSetPropertyData`** - Set device nominal sample rate

- Must be called before AudioUnit initialization
- Requires `kAudioDevicePropertyNominalSampleRate` property
- Returns `OSStatus` (noErr on success)

**`AudioObjectGetPropertyData`** - Query device nominal sample rate

- Used for verification after setting
- Same property address as set operation

**`AudioUnitSetProperty`** - Set AudioUnit stream format

- Called AFTER device sample rate is set
- Uses `kAudioUnitProperty_StreamFormat`

### Property Addresses

```cpp
// Device nominal sample rate (hardware)
AudioObjectPropertyAddress deviceSRAddr = {
  kAudioDevicePropertyNominalSampleRate,
  kAudioObjectPropertyScopeGlobal,
  kAudioObjectPropertyElementMain
};

// AudioUnit stream format (software)
kAudioUnitProperty_StreamFormat
```

## Future Considerations

### Potential Enhancements

1. **Sample rate conversion fallback** - If device can't switch to requested rate
2. **Supported rates enumeration** - Query device capabilities before setting
3. **Rate change listeners** - Detect when system changes device rate
4. **Multi-device support** - Handle aggregate devices with different rates

### Edge Cases to Test

1. **Exclusive mode applications** - Device already in use at different rate
2. **Aggregate devices** - Multiple devices with different native rates
3. **USB audio interfaces** - External devices with fixed rates
4. **System rate changes** - Audio MIDI Setup changes during playback

### Documentation Updates Needed

1. **AudioDriverConfig documentation** - Explain sample rate guarantees
2. **Platform driver comparison** - Document rate-setting across platforms
3. **Troubleshooting guide** - Common sample rate issues
4. **API usage examples** - Correct initialization sequence

## References

[1] Apple Developer Documentation - AudioObjectSetPropertyData
https://developer.apple.com/documentation/coreaudio/1422524-audioobjectsetpropertydata

[2] Apple Developer Documentation - kAudioDevicePropertyNominalSampleRate
https://developer.apple.com/documentation/coreaudio/kaudiodevicepropertynominalsamplerate

[3] Core Audio Book - Device Management
https://www.subfurther.com/blog/core-audio-101/

[4] Professional Audio Developer Forum - Sample Rate Management
https://forum.juce.com/t/sample-rate-mismatch-issues/

## Related Issues

- **ORP068** - SDK Implementation Plan (M2: Real-Time Infrastructure)
- **OCC021** - Orpheus Clip Composer Product Vision
- **OCC027** - API Contracts (IAudioDriver interface)
- **OCC029** - SDK Enhancement Recommendations

## Contributors

- **Identified by:** User testing (Chris Lyons)
- **Diagnosed by:** Claude Code (AI Assistant)
- **Fixed by:** Claude Code with SDK Team consultation
- **Verified by:** Chris Lyons

---

**Key Takeaway:** CoreAudio requires setting BOTH the device's nominal sample rate AND the AudioUnit's stream format. Setting only the format causes the device to resample incorrectly, leading to playback speed and quality issues. Always configure the device hardware before the AudioUnit software layer.
