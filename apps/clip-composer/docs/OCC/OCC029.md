# OCC029 SDK Enhancement Recommendations for Clip Composer v1.0

**Version:** 1.0
**Date:** October 12, 2025
**Status:** Draft
**Purpose:** Identify Orpheus SDK enhancements required to fully support Orpheus Clip Composer MVP
**References:** OCC027 (API Contracts), OCC026 (MVP Definition), OCC023 (Component Architecture)

---

## Executive Summary

This document analyzes the current Orpheus SDK (v0.2.0) against Orpheus Clip Composer's requirements and recommends enhancements to ensure the SDK is fully provisioned for OCC's MVP (Months 1-6) and future releases (v1.0, v2.0).

**Current SDK Status:**
- ✅ Offline rendering with deterministic audio path
- ✅ Session graph with tracks, clips, tempo
- ✅ JSON session serialization
- ✅ ABI versioning system
- ❌ Real-time playback engine
- ❌ Multi-channel audio routing
- ❌ Platform audio driver integration (CoreAudio, ASIO, WASAPI)
- ❌ Audio file decoding abstraction
- ❌ Performance monitoring/diagnostics

**Recommendation:** Add 5 core modules to SDK, incrementally, aligned with OCC026 MVP timeline.

---

## 1. Gap Analysis: Current SDK vs OCC Requirements

### 1.1 What SDK Currently Provides

| Component | Location | Capabilities | Status for OCC |
|-----------|----------|--------------|----------------|
| `SessionGraph` | `src/core/session/session_graph.h` | Tracks, clips, tempo, transport state | ✅ Good foundation |
| `render_tracks()` | `src/core/render/render_tracks.h` | Offline deterministic rendering | ✅ Useful for export |
| JSON helpers | `src/core/session/json_helpers.h` | Session serialization | ✅ Matches OCC data model |
| `AbiVersion` | `include/orpheus/abi_version.h` | Cross-version communication | ✅ Critical for stability |
| Adapters | `adapters/minhost/`, `adapters/reaper/` | CLI host, REAPER extension | ⚠️ Reference examples only |

**Assessment:** Strong foundation for offline workflows, but missing real-time playback infrastructure.

### 1.2 What OCC Requires (from OCC027)

| Interface | Required Capabilities | SDK Status | Priority |
|-----------|----------------------|------------|----------|
| `ISessionGraph` | Add/remove/update clips, set tempo, register callbacks | ⚠️ Partial (no callbacks) | **CRITICAL** |
| `ITransportController` | Start/stop clips, sample-accurate timing, playback state | ❌ Missing | **CRITICAL** |
| `IRoutingMatrix` | Multi-channel routing (4 Clip Groups, master out, aux sends) | ❌ Missing | **CRITICAL** |
| `IAudioFileReader` | Decode WAV/AIFF/FLAC, stream to buffers, metadata extraction | ❌ Missing | **CRITICAL** |
| `IPerformanceMonitor` | CPU usage, buffer underruns, latency, memory, thread safety | ❌ Missing | **HIGH** |
| Real-time audio I/O | CoreAudio/ASIO/WASAPI integration, callback threading | ❌ Missing | **CRITICAL** |

**Gap Summary:** 5 major modules needed for OCC MVP.

### 1.3 Additional Enhancements for OCC v1.0+ (Deferred)

| Feature | Required SDK Support | OCC Version | Priority |
|---------|---------------------|-------------|----------|
| Recording to buttons | Input audio graphs, buffer management, disk streaming | v1.0 | Medium |
| Time-stretch/pitch-shift | DSP library integration (Rubber Band), real-time processing | v1.0 | Medium |
| Remote control (OSC/MIDI) | Protocol adapters, command mapping | v1.0 | Low |
| Master/slave linking | Advanced transport synchronization | v1.0 | Medium |
| AutoPlay/jukebox | Clip queue management, crossfade engine | v2.0 | Low |
| GPI triggering | External hardware integration | v2.0 | Low |

---

## 2. Priority Enhancements for MVP (Months 1-6)

### 2.1 Module 1: Real-Time Transport Controller (CRITICAL)

**Purpose:** Enable sample-accurate clip playback with start/stop control.

**Proposed Location:** `src/core/transport/transport_controller.h`

**Key Responsibilities:**
- Start/stop individual clips or entire Clip Groups
- Maintain sample-accurate playback position
- Trigger callbacks on state changes (clip started, stopped, loop point reached)
- Integrate with `SessionGraph` for clip metadata lookup

**Interface Specification** (matching OCC027):

```cpp
namespace orpheus::sdk {

enum class PlaybackState : uint8_t {
    Stopped = 0,
    Playing = 1,
    Paused = 2,
    Stopping = 3  // Fade-out in progress
};

struct TransportPosition {
    int64_t samples;           // Absolute position in samples
    double seconds;            // Derived (samples / sample_rate)
    double beats;              // Derived (seconds * tempo / 60.0)
};

class ITransportCallback {
public:
    virtual ~ITransportCallback() = default;

    // Invoked on UI thread (NOT audio thread)
    virtual void onClipStarted(ClipHandle handle, TransportPosition position) = 0;
    virtual void onClipStopped(ClipHandle handle, TransportPosition position) = 0;
    virtual void onClipLooped(ClipHandle handle, TransportPosition position) = 0;
    virtual void onBufferUnderrun(TransportPosition position) = 0;
};

class ITransportController {
public:
    virtual ~ITransportController() = default;

    // Clip control (thread-safe, callable from UI thread)
    virtual SessionGraphError startClip(ClipHandle handle) = 0;
    virtual SessionGraphError stopClip(ClipHandle handle) = 0;
    virtual SessionGraphError stopAllClips() = 0;
    virtual SessionGraphError stopAllInGroup(uint8_t groupIndex) = 0;

    // State queries (thread-safe)
    virtual PlaybackState getClipState(ClipHandle handle) const = 0;
    virtual bool isClipPlaying(ClipHandle handle) const = 0;
    virtual TransportPosition getCurrentPosition() const = 0;

    // Callback registration (UI thread only)
    virtual void setCallback(ITransportCallback* callback) = 0;
};

}  // namespace orpheus::sdk
```

**Implementation Notes:**
- Lock-free audio thread using `std::atomic` for state changes
- Command queue for start/stop requests (UI → Audio thread)
- Callback invocation via message queue (Audio → UI thread)
- Fade-out on stop (10ms default, configurable)

**Testing Strategy:**
- Unit tests: Sample-accurate timing (±1 sample tolerance)
- Integration tests: Start 16 clips simultaneously, verify no dropouts
- Stress tests: Rapid start/stop (100 triggers/second)

**Timeline:** Month 1-2 of OCC MVP

---

### 2.2 Module 2: Audio File Reader Abstraction (CRITICAL)

**Purpose:** Decode audio files (WAV, AIFF, FLAC) and stream to playback buffers.

**Proposed Location:** `src/core/audio_io/audio_file_reader.h`

**Key Responsibilities:**
- Read audio file metadata (sample rate, channels, duration, format)
- Stream audio data into ring buffers (non-blocking)
- Handle sample rate conversion (if needed)
- Verify file integrity (SHA-256 hash matching OCC022 schema)

**Interface Specification:**

```cpp
namespace orpheus::sdk {

enum class AudioFileFormat : uint8_t {
    WAV = 0,
    AIFF = 1,
    FLAC = 2,
    Unknown = 255
};

struct AudioFileMetadata {
    AudioFileFormat format;
    uint32_t sample_rate;
    uint16_t num_channels;
    int64_t duration_samples;
    uint16_t bit_depth;
    std::string codec;
    std::string file_hash_sha256;
};

class IAudioFileReader {
public:
    virtual ~IAudioFileReader() = default;

    // Open file and read metadata (UI/background thread)
    virtual Result<AudioFileMetadata> open(const std::string& file_path) = 0;

    // Read samples into buffer (background thread)
    // Returns number of samples read (or error)
    virtual Result<size_t> readSamples(float** buffers, size_t num_channels, size_t num_samples) = 0;

    // Seek to sample position (background thread)
    virtual SessionGraphError seek(int64_t sample_position) = 0;

    // Close file (background thread)
    virtual void close() = 0;

    // Query current position (thread-safe)
    virtual int64_t getCurrentPosition() const = 0;
};

// Factory function
std::unique_ptr<IAudioFileReader> createAudioFileReader();

}  // namespace orpheus::sdk
```

**Recommended Library:** `libsndfile` (LGPL, widely used)
- Supports WAV, AIFF, FLAC, and 20+ other formats
- Mature (20+ years), well-tested
- Cross-platform (Windows, macOS, Linux)
- Optional: Add `dr_libs` (public domain) as fallback for embedded systems

**Pre-loading Strategy:**
- Load first 5 seconds into RAM on clip load (low-latency start)
- Stream remainder from disk in background thread
- Ring buffer: 10-second capacity (configurable)

**Testing Strategy:**
- Unit tests: Read 10+ audio file formats, verify sample accuracy
- Stress tests: Read 16 files simultaneously (simulate 16-clip playback)
- Edge cases: Corrupt files, missing files, unsupported formats

**Timeline:** Month 1-2 of OCC MVP

---

### 2.3 Module 3: Multi-Channel Routing Matrix (CRITICAL)

**Purpose:** Route audio from clips → Clip Groups → Master Output with gain control.

**Proposed Location:** `src/core/routing/routing_matrix.h`

**Key Responsibilities:**
- 4 Clip Groups with independent output busses
- Master output bus (stereo or configurable channels)
- Per-clip routing to group
- Per-group routing to master (with aux sends in v1.0)
- Real-time gain adjustment (no clicks/pops)

**Interface Specification:**

```cpp
namespace orpheus::sdk {

constexpr uint8_t MAX_CLIP_GROUPS = 4;
constexpr uint8_t MAX_CHANNELS = 32;

struct RoutingConfig {
    uint8_t num_output_channels{2};  // Default: stereo
    float master_gain_db{0.0f};      // -60 to +12 dB
    bool master_mute{false};
};

struct ClipGroupConfig {
    uint8_t group_index;             // 0-3
    float gain_db{0.0f};             // -60 to +12 dB
    bool mute{false};
    bool solo{false};
    uint8_t output_channels[MAX_CHANNELS]{0};  // Map to physical outputs
};

class IRoutingMatrix {
public:
    virtual ~IRoutingMatrix() = default;

    // Configuration (UI thread only)
    virtual SessionGraphError configure(const RoutingConfig& config) = 0;
    virtual SessionGraphError setClipGroupConfig(const ClipGroupConfig& config) = 0;

    // Runtime control (thread-safe, smooth transitions)
    virtual void setClipGroup(ClipHandle handle, uint8_t group_index) = 0;
    virtual void setClipGroupGain(uint8_t group_index, float gain_db) = 0;
    virtual void setClipGroupMute(uint8_t group_index, bool mute) = 0;
    virtual void setMasterGain(float gain_db) = 0;
    virtual void setMasterMute(bool mute) = 0;

    // State queries (thread-safe)
    virtual ClipGroupConfig getClipGroupConfig(uint8_t group_index) const = 0;
    virtual RoutingConfig getRoutingConfig() const = 0;
};

}  // namespace orpheus::sdk
```

**Implementation Notes:**
- Gain changes smoothed over 10ms (ramp to avoid clicks)
- Lock-free atomic operations for gain/mute state
- Summing: Use double-precision for clip accumulation, convert to float for output
- Clipping protection: Optional soft-clip limiter on master output

**Testing Strategy:**
- Unit tests: Verify routing correctness (clip → group → master)
- Audio tests: Verify no clicks/pops on gain changes
- Performance tests: CPU usage with 16 active clips

**Timeline:** Month 3-4 of OCC MVP

---

### 2.4 Module 4: Platform Audio Driver Integration (CRITICAL)

**Purpose:** Integrate with CoreAudio (macOS), ASIO (Windows), WASAPI (Windows) for low-latency I/O.

**Proposed Location:** `src/platform/audio_drivers/` (per-platform subdirectories)

**Proposed Structure:**
```
src/platform/audio_drivers/
├── audio_driver_interface.h         # Abstract interface
├── coreaudio/
│   ├── coreaudio_driver.h
│   └── coreaudio_driver.cpp
├── asio/
│   ├── asio_driver.h
│   └── asio_driver.cpp
├── wasapi/
│   ├── wasapi_driver.h
│   └── wasapi_driver.cpp
└── dummy/                            # For testing without hardware
    ├── dummy_driver.h
    └── dummy_driver.cpp
```

**Interface Specification:**

```cpp
namespace orpheus::sdk::platform {

enum class AudioDriverType : uint8_t {
    CoreAudio = 0,
    ASIO = 1,
    WASAPI = 2,
    Dummy = 255  // For testing
};

struct AudioDeviceInfo {
    std::string device_id;
    std::string device_name;
    uint32_t default_sample_rate;
    uint16_t max_input_channels;
    uint16_t max_output_channels;
    std::vector<uint32_t> supported_sample_rates;
};

struct AudioDriverConfig {
    std::string device_id;           // Empty = default device
    uint32_t sample_rate{48000};     // 44100, 48000, 96000
    uint16_t buffer_size{512};       // Samples per buffer (128, 256, 512, 1024)
    uint16_t num_input_channels{0};  // 0 = no input (MVP)
    uint16_t num_output_channels{2}; // Stereo default
};

using AudioCallback = std::function<void(const float** input_buffers,
                                          float** output_buffers,
                                          size_t num_frames)>;

class IAudioDriver {
public:
    virtual ~IAudioDriver() = default;

    // Enumerate available devices (UI thread)
    virtual std::vector<AudioDeviceInfo> getAvailableDevices() = 0;

    // Initialize driver with configuration (UI thread)
    virtual SessionGraphError initialize(const AudioDriverConfig& config) = 0;

    // Start/stop audio engine (UI thread)
    virtual SessionGraphError start(AudioCallback callback) = 0;
    virtual SessionGraphError stop() = 0;

    // Query current configuration (thread-safe)
    virtual AudioDriverConfig getCurrentConfig() const = 0;
    virtual bool isRunning() const = 0;

    // Latency reporting (samples)
    virtual uint32_t getInputLatency() const = 0;
    virtual uint32_t getOutputLatency() const = 0;
};

// Factory function (creates appropriate driver for platform)
std::unique_ptr<IAudioDriver> createAudioDriver(AudioDriverType type);

}  // namespace orpheus::sdk::platform
```

**Implementation Recommendations:**

**CoreAudio (macOS):**
- Use `AudioUnit` API (low-level, mature)
- Default buffer size: 512 samples (10.7ms @ 48kHz)
- Automatic sample rate conversion if needed
- Device enumeration via `AudioObjectGetPropertyData`

**ASIO (Windows - Professional):**
- Link against ASIO SDK (Steinberg, free download)
- Use `ASIOInit()`, `ASIOCreateBuffers()`, `ASIOStart()`
- Default buffer size: 256 samples (5.3ms @ 48kHz)
- **Critical:** No ASIO drivers on consumer Windows machines (require WASAPI fallback)

**WASAPI (Windows - Consumer):**
- Use Exclusive Mode for low latency (<10ms)
- Shared Mode fallback (higher latency, but universal)
- Default buffer size: 480 samples (10ms @ 48kHz)
- Device enumeration via `IMMDeviceEnumerator`

**Testing Strategy:**
- Unit tests: Use dummy driver to verify callback invocation
- Integration tests: Verify latency <5ms (ASIO), <10ms (WASAPI/CoreAudio)
- Stress tests: Run for 24 hours, detect buffer underruns

**Timeline:** Month 1-2 of OCC MVP (parallel with Transport Controller)

---

### 2.5 Module 5: Performance Monitor (HIGH Priority)

**Purpose:** Real-time diagnostics for CPU usage, buffer underruns, latency, and memory.

**Proposed Location:** `src/core/diagnostics/performance_monitor.h`

**Key Responsibilities:**
- Track audio thread CPU usage (percentage of available time)
- Detect buffer underruns (audio dropouts)
- Report end-to-end latency (input → output, includes hardware)
- Monitor memory allocations (warn on audio thread allocations)
- Thread-safe queries from UI thread

**Interface Specification:**

```cpp
namespace orpheus::sdk {

struct PerformanceMetrics {
    float cpu_usage_percent;         // 0.0 - 100.0 (audio thread only)
    uint32_t buffer_underruns;       // Total count since start
    uint32_t buffer_underruns_delta; // Count since last query
    float latency_ms;                // End-to-end (input + processing + output)
    uint64_t memory_usage_bytes;     // Total allocated by SDK
    uint32_t active_clips;           // Currently playing
    double uptime_seconds;           // Time since audio engine start
};

class IPerformanceMonitor {
public:
    virtual ~IPerformanceMonitor() = default;

    // Query current metrics (thread-safe)
    virtual PerformanceMetrics getMetrics() const = 0;

    // Reset counters (e.g., buffer underruns)
    virtual void reset() = 0;

    // Enable/disable detailed profiling (may impact performance)
    virtual void setProfilingEnabled(bool enabled) = 0;

    // Get per-clip CPU breakdown (if profiling enabled)
    virtual std::vector<std::pair<ClipHandle, float>> getPerClipCPU() const = 0;
};

}  // namespace orpheus::sdk
```

**Implementation Notes:**
- CPU measurement: High-resolution timer (RDTSC on x86, Mach Absolute Time on macOS)
- Buffer underrun detection: Track missed audio callbacks
- Memory tracking: Hook into allocators (debug builds only)
- Minimal overhead: <0.5% CPU impact when profiling disabled

**UI Integration (OCC):**
- Show metrics in bottom panel (CPU meter, latency display)
- Visual indicator for buffer underruns (flashing red icon)
- Export metrics to CSV for diagnostics

**Testing Strategy:**
- Unit tests: Verify CPU calculation accuracy
- Stress tests: Induce underruns by overloading CPU, verify detection

**Timeline:** Month 4-5 of OCC MVP

---

## 3. Implementation Recommendations

### 3.1 Incremental Development Approach

**Phase 1 (Month 1-2): Audio I/O + Transport Foundation**
1. Implement `IAudioDriver` with CoreAudio (macOS) and WASAPI (Windows)
2. Implement `IAudioFileReader` using `libsndfile`
3. Create basic `ITransportController` (single-clip playback)
4. Write unit tests for each module

**Phase 2 (Month 3-4): Routing + Multi-Clip**
1. Implement `IRoutingMatrix` with 4 Clip Groups
2. Extend `ITransportController` for multi-clip playback
3. Add callback system for transport events
4. Integration tests: 16 simultaneous clips

**Phase 3 (Month 5-6): Diagnostics + Polish**
1. Implement `IPerformanceMonitor`
2. ASIO driver support (Windows professional)
3. Optimize CPU usage (<30% target with 16 clips)
4. Cross-platform validation (macOS + Windows)

### 3.2 Directory Structure Proposal

```
orpheus-sdk/
├── src/
│   ├── core/
│   │   ├── session/              # Existing: SessionGraph, JSON helpers
│   │   ├── render/               # Existing: Offline rendering
│   │   ├── transport/            # NEW: Real-time transport controller
│   │   │   ├── transport_controller.h
│   │   │   ├── transport_controller.cpp
│   │   │   └── clip_scheduler.h  # Internal: Manages active clips
│   │   ├── routing/              # NEW: Multi-channel routing
│   │   │   ├── routing_matrix.h
│   │   │   ├── routing_matrix.cpp
│   │   │   └── gain_smoother.h   # Internal: Click-free gain changes
│   │   ├── audio_io/             # NEW: Audio file I/O
│   │   │   ├── audio_file_reader.h
│   │   │   ├── audio_file_reader_libsndfile.cpp
│   │   │   └── ring_buffer.h     # Internal: Lock-free ring buffer
│   │   └── diagnostics/          # NEW: Performance monitoring
│   │       ├── performance_monitor.h
│   │       └── performance_monitor.cpp
│   └── platform/
│       └── audio_drivers/        # NEW: Platform-specific drivers
│           ├── audio_driver_interface.h
│           ├── coreaudio/
│           │   ├── coreaudio_driver.h
│           │   └── coreaudio_driver.cpp
│           ├── asio/
│           │   ├── asio_driver.h
│           │   └── asio_driver.cpp
│           ├── wasapi/
│           │   ├── wasapi_driver.h
│           │   └── wasapi_driver.cpp
│           └── dummy/
│               ├── dummy_driver.h
│               └── dummy_driver.cpp
├── include/orpheus/
│   ├── transport_controller.h    # Public API
│   ├── routing_matrix.h          # Public API
│   ├── audio_file_reader.h       # Public API
│   ├── performance_monitor.h     # Public API
│   └── audio_driver.h            # Public API
├── tests/
│   ├── transport/
│   │   ├── transport_controller_test.cpp
│   │   └── sample_accuracy_test.cpp
│   ├── routing/
│   │   └── routing_matrix_test.cpp
│   ├── audio_io/
│   │   └── audio_file_reader_test.cpp
│   └── platform/
│       ├── coreaudio_driver_test.cpp
│       └── dummy_driver_test.cpp
└── adapters/
    └── minhost/
        └── main.cpp              # Update to use new real-time APIs
```

### 3.3 CMake Build System Updates

**Proposed CMake Options:**

```cmake
# New options for real-time features
option(ORPHEUS_ENABLE_REALTIME "Build Orpheus real-time playback engine" ON)
option(ORPHEUS_ENABLE_COREAUDIO "Build CoreAudio driver (macOS)" ON)
option(ORPHEUS_ENABLE_ASIO "Build ASIO driver (Windows)" OFF)  # Requires ASIO SDK
option(ORPHEUS_ENABLE_WASAPI "Build WASAPI driver (Windows)" ON)
option(ORPHEUS_USE_LIBSNDFILE "Use libsndfile for audio file I/O" ON)

# Default: Enable real-time features for OCC
if(ORPHEUS_ENABLE_REALTIME)
    add_subdirectory(src/core/transport)
    add_subdirectory(src/core/routing)
    add_subdirectory(src/core/audio_io)
    add_subdirectory(src/core/diagnostics)
    add_subdirectory(src/platform/audio_drivers)
endif()

# Platform-specific drivers
if(APPLE AND ORPHEUS_ENABLE_COREAUDIO)
    target_link_libraries(orpheus_audio_drivers PRIVATE "-framework CoreAudio")
endif()

if(WIN32 AND ORPHEUS_ENABLE_WASAPI)
    target_link_libraries(orpheus_audio_drivers PRIVATE "mmdevapi.lib")
endif()

if(WIN32 AND ORPHEUS_ENABLE_ASIO)
    # User must provide ASIO SDK path
    if(NOT DEFINED ASIO_SDK_PATH)
        message(FATAL_ERROR "ASIO_SDK_PATH must be set when ORPHEUS_ENABLE_ASIO=ON")
    endif()
    target_include_directories(orpheus_audio_drivers PRIVATE ${ASIO_SDK_PATH})
endif()

# libsndfile dependency
if(ORPHEUS_USE_LIBSNDFILE)
    find_package(SndFile REQUIRED)
    target_link_libraries(orpheus_audio_io PRIVATE SndFile::sndfile)
endif()
```

**Targets:**

```cmake
# New library targets
add_library(orpheus_transport src/core/transport/transport_controller.cpp)
add_library(orpheus_routing src/core/routing/routing_matrix.cpp)
add_library(orpheus_audio_io src/core/audio_io/audio_file_reader_libsndfile.cpp)
add_library(orpheus_diagnostics src/core/diagnostics/performance_monitor.cpp)
add_library(orpheus_audio_drivers src/platform/audio_drivers/*.cpp)

# Link dependencies
target_link_libraries(orpheus_transport PRIVATE orpheus_session orpheus_audio_io)
target_link_libraries(orpheus_routing PRIVATE orpheus_session)
target_link_libraries(orpheus_audio_drivers PRIVATE orpheus_transport orpheus_routing)

# Update existing core library to depend on new modules
target_link_libraries(orpheus_core PUBLIC
    orpheus_session
    orpheus_clipgrid
    orpheus_render
    $<$<BOOL:${ORPHEUS_ENABLE_REALTIME}>:orpheus_transport>
    $<$<BOOL:${ORPHEUS_ENABLE_REALTIME}>:orpheus_routing>
    $<$<BOOL:${ORPHEUS_ENABLE_REALTIME}>:orpheus_audio_io>
    $<$<BOOL:${ORPHEUS_ENABLE_REALTIME}>:orpheus_diagnostics>
    $<$<BOOL:${ORPHEUS_ENABLE_REALTIME}>:orpheus_audio_drivers>
)
```

### 3.4 External Dependencies

**Required:**
- `libsndfile` (LGPL 2.1) - Audio file I/O
  - Installation: `brew install libsndfile` (macOS), `vcpkg install libsndfile` (Windows)
  - Alternative: Bundle as submodule if licensing permits

**Optional:**
- ASIO SDK (Steinberg, free download, proprietary license)
  - User must download separately (cannot redistribute)
  - Only needed for professional Windows setups

**No Other Dependencies:** All other code uses standard C++20 + platform APIs.

---

## 4. Timeline Alignment with OCC MVP (Months 1-6)

**SDK Work Parallel to OCC Development:**

### Month 1: Foundation & Audio Engine
**SDK Priorities:**
- ✅ `IAudioDriver` implementation (CoreAudio + WASAPI)
- ✅ `IAudioFileReader` implementation (`libsndfile`)
- ✅ Basic `ITransportController` (single-clip playback)
- ✅ Dummy driver for testing

**OCC Work (can start with stubs):**
- JUCE project setup
- Basic UI layout (grid, bottom panel)
- Stub integration with SDK interfaces

### Month 2: Clip Grid & Basic Playback
**SDK Priorities:**
- ✅ Multi-clip playback in `ITransportController`
- ✅ Transport callbacks (clip started/stopped)
- ✅ Sample-accurate timing tests (±1 sample tolerance)

**OCC Work:**
- Clip triggering (mouse/keyboard)
- Waveform display (pre-render in background)
- Load clips from filesystem

### Month 3: Waveform Editor & Editing
**SDK Priorities:**
- ✅ `IRoutingMatrix` implementation (4 Clip Groups)
- ✅ Gain control with smoothing (no clicks/pops)
- ✅ Integration tests: 16 simultaneous clips

**OCC Work:**
- Waveform editor (trim IN/OUT, cue points)
- Clip metadata editing
- Session save/load (JSON)

### Month 4: Session Management & Routing
**SDK Priorities:**
- ✅ `IPerformanceMonitor` implementation
- ✅ Master output routing
- ✅ Cross-platform validation (macOS + Windows)

**OCC Work:**
- Clip Groups UI (assign clips, routing)
- Bottom panel (transport, routing, diagnostics)
- Session migration (relative file paths)

### Month 5: Cross-Platform Polish (macOS + Windows)
**SDK Priorities:**
- ✅ ASIO driver support (Windows professional)
- ✅ CPU optimization (<30% with 16 clips)
- ✅ Memory leak detection (sanitizers)

**OCC Work:**
- Windows-specific UI polish
- Keyboard shortcuts
- Auto-save (incremental, non-blocking)

### Month 6: Beta Testing
**SDK Priorities:**
- ✅ Bug fixes from OCC integration
- ✅ Performance profiling (identify bottlenecks)
- ✅ Documentation (API docs, integration guide)

**OCC Work:**
- 10-user beta (5 broadcast, 5 theater)
- Crash reporting
- User feedback integration

**Critical Path:** SDK Months 1-4 must complete on schedule to avoid blocking OCC development.

---

## 5. Testing Strategy

### 5.1 Unit Tests (GoogleTest)

**Transport Controller Tests:**
```cpp
TEST(TransportController, StartStopSingleClip) {
    auto transport = createTransportController();
    auto clip = /* load test clip */;
    EXPECT_EQ(transport->startClip(clip), SessionGraphError::OK);
    EXPECT_EQ(transport->getClipState(clip), PlaybackState::Playing);
    EXPECT_EQ(transport->stopClip(clip), SessionGraphError::OK);
    EXPECT_EQ(transport->getClipState(clip), PlaybackState::Stopped);
}

TEST(TransportController, SampleAccurateTiming) {
    auto transport = createTransportController();
    auto clip = /* load test clip with known samples */;

    int64_t expected_position = 48000;  // 1 second @ 48kHz
    transport->startClip(clip);
    std::this_thread::sleep_for(std::chrono::seconds(1));

    int64_t actual_position = transport->getCurrentPosition().samples;
    EXPECT_NEAR(actual_position, expected_position, 1);  // ±1 sample tolerance
}
```

**Routing Matrix Tests:**
```cpp
TEST(RoutingMatrix, ClipGroupAssignment) {
    auto routing = createRoutingMatrix();
    auto clip = /* test clip */;

    routing->setClipGroup(clip, 2);  // Assign to Clip Group 2
    EXPECT_EQ(routing->getClipGroupConfig(2).group_index, 2);
}

TEST(RoutingMatrix, GainSmoothingNoClicks) {
    auto routing = createRoutingMatrix();
    float gain_before = routing->getClipGroupConfig(0).gain_db;

    routing->setClipGroupGain(0, -6.0f);  // Reduce by 6dB
    std::this_thread::sleep_for(std::chrono::milliseconds(20));  // Wait for smoothing

    float gain_after = routing->getClipGroupConfig(0).gain_db;
    EXPECT_NEAR(gain_after, -6.0f, 0.1f);
}
```

### 5.2 Integration Tests

**16-Clip Simultaneous Playback:**
```cpp
TEST(Integration, SixteenClipsNoDropouts) {
    auto transport = createTransportController();
    auto monitor = createPerformanceMonitor();

    std::vector<ClipHandle> clips;
    for (int i = 0; i < 16; ++i) {
        clips.push_back(/* load test clip */);
    }

    for (auto clip : clips) {
        transport->startClip(clip);
    }

    std::this_thread::sleep_for(std::chrono::seconds(10));

    auto metrics = monitor->getMetrics();
    EXPECT_EQ(metrics.buffer_underruns, 0);
    EXPECT_LT(metrics.cpu_usage_percent, 30.0f);
}
```

**Cross-Platform Latency Verification:**
```cpp
TEST(Integration, LatencyUnder10ms) {
    auto driver = createAudioDriver(AudioDriverType::CoreAudio);
    AudioDriverConfig config;
    config.sample_rate = 48000;
    config.buffer_size = 512;

    EXPECT_EQ(driver->initialize(config), SessionGraphError::OK);

    uint32_t input_latency = driver->getInputLatency();
    uint32_t output_latency = driver->getOutputLatency();
    float total_latency_ms = (input_latency + output_latency) / 48.0f;

    EXPECT_LT(total_latency_ms, 10.0f);
}
```

### 5.3 Stress Tests

**24-Hour Stability Test:**
- Run minhost adapter with 16 clips looping
- Monitor for crashes, memory leaks, buffer underruns
- Target: >100 hours MTBF (Mean Time Between Failures)

**Rapid Trigger Test:**
- Trigger 100 clips per second (start/stop)
- Verify no audio dropouts
- Verify no memory leaks

**File Corruption Test:**
- Attempt to load corrupt audio files
- Verify graceful error handling (no crashes)

---

## 6. Documentation Needs

### 6.1 SDK API Documentation (Doxygen)

**New header files require Doxygen comments:**
- `transport_controller.h` - Sample-accurate playback API
- `routing_matrix.h` - Multi-channel routing API
- `audio_file_reader.h` - Audio file I/O API
- `audio_driver.h` - Platform audio driver API
- `performance_monitor.h` - Diagnostics API

**Example Doxygen Comment:**
```cpp
/**
 * @brief Start playback of a specific clip.
 *
 * This function is thread-safe and can be called from the UI thread.
 * The clip will begin playing on the next audio buffer callback.
 *
 * @param handle The clip to start (must be a valid handle from SessionGraph)
 * @return SessionGraphError::OK on success, or error code on failure
 *
 * @note If the clip is already playing, this function has no effect.
 * @note Playback will honor trim points and fade-in settings from clip metadata.
 *
 * @see stopClip(), getClipState()
 */
virtual SessionGraphError startClip(ClipHandle handle) = 0;
```

### 6.2 Integration Guide for OCC Developers

**Document:** `/docs/integration/OCC_SDK_Integration_Guide.md`

**Contents:**
1. How to link against new SDK modules
2. Initialization sequence (audio driver → transport → routing)
3. Threading model (UI thread vs audio thread)
4. Error handling best practices
5. Performance profiling with `IPerformanceMonitor`
6. Example: Complete clip playback workflow (stub → real implementation)

### 6.3 Platform-Specific Guides

**Document:** `/docs/platform/CoreAudio_Integration.md`
- CoreAudio setup on macOS
- Buffer size recommendations
- Device enumeration
- Troubleshooting (e.g., sample rate mismatches)

**Document:** `/docs/platform/ASIO_WASAPI_Integration.md`
- ASIO SDK installation on Windows
- WASAPI Exclusive vs Shared Mode
- Driver selection logic (ASIO if available, else WASAPI)
- Troubleshooting (e.g., "No ASIO drivers found")

---

## 7. Long-Term Roadmap (v1.0+ Features)

### 7.1 Recording Support (OCC v1.0)

**SDK Requirements:**
- `IAudioInputGraph` - Capture input from audio drivers
- `IAudioFileWriter` - Write WAV/AIFF files to disk
- `IRecordingBuffer` - Ring buffer for recording (non-blocking writes)

**Interface Sketch:**
```cpp
class IAudioInputGraph {
public:
    virtual SessionGraphError startRecording(const RecordingConfig& config) = 0;
    virtual SessionGraphError stopRecording() = 0;
    virtual bool isRecording() const = 0;
    virtual std::string getRecordedFilePath() const = 0;
};

struct RecordingConfig {
    std::string output_file_path;
    uint32_t sample_rate{48000};
    uint16_t num_channels{2};
    AudioFileFormat format{AudioFileFormat::WAV};
    uint16_t bit_depth{24};  // 16, 24, or 32
};
```

**Timeline:** Month 7-9 of OCC development (post-MVP)

### 7.2 DSP Processing (OCC v1.0)

**SDK Requirements:**
- `IDSPProcessor` interface (pluggable DSP)
- Integration points for Rubber Band (time-stretch, pitch-shift)
- Real-time parameter updates

**Interface Sketch:**
```cpp
class IDSPProcessor {
public:
    virtual void process(const float** input, float** output, size_t num_samples) = 0;
    virtual void setParameter(const std::string& param_name, float value) = 0;
    virtual void reset() = 0;  // Clear internal state
};

// Factory for Rubber Band integration
std::unique_ptr<IDSPProcessor> createTimeStretchProcessor(double time_ratio);
std::unique_ptr<IDSPProcessor> createPitchShiftProcessor(double semitones);
```

**Timeline:** Month 10-12 of OCC development (v1.0)

### 7.3 Remote Control Protocols (OCC v1.0)

**SDK Requirements:**
- `IRemoteControlServer` - WebSocket, OSC, MIDI listeners
- Command mapping (e.g., MIDI note 60 → start clip 0)

**Interface Sketch:**
```cpp
class IRemoteControlServer {
public:
    virtual SessionGraphError startServer(uint16_t port) = 0;
    virtual SessionGraphError stopServer() = 0;
    virtual void registerCommand(const std::string& command, std::function<void()> callback) = 0;
};

// Example: Map OSC message to clip trigger
remote_server->registerCommand("/clip/start/0", [transport]() {
    transport->startClip(clip_handle_0);
});
```

**Timeline:** Month 10-12 of OCC development (v1.0)

### 7.4 Advanced Transport Features (OCC v1.0)

**SDK Requirements:**
- Master/slave linking (clips start/stop together)
- AutoPlay (jukebox mode with crossfades)
- Rehearsal mode (silent playback with visual feedback)

**Interface Additions:**
```cpp
class ITransportController {
    // Master/slave linking
    virtual void linkClips(ClipHandle master, ClipHandle slave) = 0;
    virtual void unlinkClips(ClipHandle master, ClipHandle slave) = 0;

    // AutoPlay (jukebox mode)
    virtual void setAutoPlay(const std::vector<ClipHandle>& playlist) = 0;
    virtual void setCrossfadeDuration(double seconds) = 0;

    // Rehearsal mode
    virtual void setRehearsalMode(bool enabled) = 0;  // Mute audio, show visual feedback
};
```

**Timeline:** Month 10-12 of OCC development (v1.0)

---

## 8. Risk Assessment & Mitigation

### 8.1 Technical Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Buffer underruns on low-end hardware | Medium | High | Adaptive buffer sizing, performance profiling |
| Cross-platform audio driver issues | High | High | Dummy driver for testing, extensive platform testing |
| libsndfile licensing concerns (LGPL) | Low | Medium | DR_LIBS fallback (public domain), legal review |
| ASIO SDK redistribution restrictions | High | Low | Document manual installation, bundle WASAPI fallback |
| Sample-accurate timing drift | Low | High | Rigorous testing (±1 sample tolerance), atomic operations |

### 8.2 Schedule Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| SDK Months 1-2 delay (audio I/O) | Medium | Critical | Start early, parallel development with OCC stubs |
| ASIO integration complexity | High | Medium | Defer to Month 5, prioritize WASAPI for MVP |
| Performance optimization overruns | Medium | High | Continuous profiling, early optimization |
| Cross-platform bugs (macOS vs Windows) | High | Medium | CI testing on both platforms, beta testing |

### 8.3 Dependency Risks

| Dependency | Risk | Mitigation |
|------------|------|------------|
| libsndfile | Licensing (LGPL requires dynamic linking) | Link dynamically, document LGPL compliance |
| ASIO SDK | Proprietary license, user must download | Provide clear documentation, WASAPI fallback |
| JUCE (OCC) | GPL or paid license for closed-source | Budget for JUCE Indie ($40/month) or commercial |
| Rubber Band (v1.0) | AGPL or paid license | Budget for Indie license ($50/year), SoundTouch fallback |

---

## 9. Open Questions for Decision

### 9.1 SDK Architecture

**Q1:** Should `ITransportController` manage clip fades, or is that OCC's responsibility?
- **Recommendation:** SDK handles fades (10ms default on stop/start). Ensures consistent behavior across applications.

**Q2:** Should routing matrix support aux sends in MVP, or defer to v1.0?
- **Recommendation:** Defer to v1.0. MVP focus: 4 Clip Groups → Master Output only.

**Q3:** Should `IAudioFileReader` support streaming from network (HTTP), or local files only?
- **Recommendation:** Local files only for MVP. Network streaming in v2.0 (optional, behind flag).

### 9.2 Build System

**Q4:** Should real-time modules be optional (CMake flag), or always built?
- **Recommendation:** Optional (`ORPHEUS_ENABLE_REALTIME=ON` by default). Allows offline-only builds for embedded systems.

**Q5:** Should SDK bundle libsndfile, or require external installation?
- **Recommendation:** External installation (vcpkg, Homebrew). Document clearly in README.

### 9.3 Testing & QA

**Q6:** Should CI run 24-hour stability tests, or only unit/integration tests?
- **Recommendation:** Unit/integration tests in CI (fast). 24-hour tests manual/nightly (slow).

**Q7:** Should SDK provide example application (beyond minhost)?
- **Recommendation:** Yes. Create `examples/simple_player/` demonstrating all 5 interfaces.

---

## 10. Summary & Next Steps

### 10.1 Summary

**Orpheus SDK is 60% ready for OCC MVP:**
- ✅ Strong foundation: SessionGraph, offline rendering, ABI versioning
- ❌ Missing real-time infrastructure: playback, routing, audio drivers, I/O

**5 Critical Modules Required:**
1. Real-Time Transport Controller (Months 1-2)
2. Audio File Reader Abstraction (Months 1-2)
3. Multi-Channel Routing Matrix (Months 3-4)
4. Platform Audio Driver Integration (Months 1-2)
5. Performance Monitor (Months 4-5)

**Timeline:** 6 months parallel to OCC development (Months 1-6)

### 10.2 Immediate Next Steps (Week 1)

**SDK Team Actions:**
1. ✅ Review OCC029 recommendations, approve architecture
2. ✅ Create GitHub issues for 5 core modules (link to OCC027 interfaces)
3. ✅ Set up project board (Kanban: To Do, In Progress, Review, Done)
4. ✅ Install dependencies (libsndfile, ASIO SDK for Windows team)
5. ✅ Create feature branches: `feature/transport-controller`, `feature/audio-drivers`, etc.

**OCC Team Actions:**
1. ✅ Review OCC027 API contracts (confirm no changes needed)
2. ✅ Set up JUCE project with stub SDK integration
3. ✅ Create mock implementations of 5 interfaces (for parallel development)
4. ✅ Begin UI layout (clip grid, bottom panel)

**Coordination:**
- Weekly sync meeting (SDK + OCC teams)
- Shared integration tests (SDK provides, OCC runs)
- Continuous communication (Slack, GitHub issues)

### 10.3 Success Criteria

**By End of Month 2:**
- ✅ Single-clip playback working (transport + audio driver + file reader)
- ✅ CoreAudio driver tested on macOS (latency <10ms)
- ✅ WASAPI driver tested on Windows (latency <10ms)

**By End of Month 4:**
- ✅ 16 simultaneous clips playing (routing matrix)
- ✅ All 5 modules integrated with OCC
- ✅ CPU usage <30% with 16 active clips

**By End of Month 6:**
- ✅ OCC MVP complete (10-user beta)
- ✅ SDK passes all integration tests (sample accuracy, latency, stability)
- ✅ Documentation complete (API docs, integration guide)

---

## 11. Appendix: Interface Summary

### 11.1 All Required Interfaces for OCC MVP

| Interface | Source | Priority | Timeline |
|-----------|--------|----------|----------|
| `ISessionGraph` | Partially exists in SDK | Critical | Month 1 (add callbacks) |
| `ITransportController` | New module | Critical | Month 1-2 |
| `IRoutingMatrix` | New module | Critical | Month 3-4 |
| `IAudioFileReader` | New module | Critical | Month 1-2 |
| `IPerformanceMonitor` | New module | High | Month 4-5 |
| `IAudioDriver` | New module | Critical | Month 1-2 |

### 11.2 Deferred Interfaces (OCC v1.0+)

| Interface | Purpose | OCC Version | SDK Timeline |
|-----------|---------|-------------|--------------|
| `IAudioInputGraph` | Recording input | v1.0 | Month 7-9 |
| `IAudioFileWriter` | Write WAV/AIFF | v1.0 | Month 7-9 |
| `IDSPProcessor` | Time-stretch, pitch-shift | v1.0 | Month 10-12 |
| `IRemoteControlServer` | OSC, MIDI, WebSocket | v1.0 | Month 10-12 |
| `IInteractionRules` | Ovation-style logic | v2.0 | Month 13-18 |
| `ISpatialAudioRenderer` | 3D audio (basic) | v2.0 | Month 13-18 |

---

**Document Status:** Draft - Pending review by SDK and OCC teams
**Next Review Date:** October 19, 2025
**Approved By:** [Pending]

---

**End of Document**
