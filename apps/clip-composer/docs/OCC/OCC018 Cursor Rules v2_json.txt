json
Copy{
  "rules": [
    "Adhere strictly to the provided project prompt and scope. Implement all features focused on real‑time, ultra‑low‑latency audio playback, advanced DSP processing, and flexible clip management without deviating into unrelated areas.",
    "Structure the application using a modular architecture. Each major subsystem (e.g., audio engine, DSP processing, clip management, UI, driver integration, session management) must have clearly defined and well‑documented interfaces, enabling independent testing and future expansion.",
    "Prioritize real‑time performance by utilizing multi‑threaded processing and sample‑accurate DSP routines. Use optimized libraries (such as Rubber Band, SoundTouch, or ZTX DSP) to handle independent pitch and time adjustments while ensuring minimal overhead in the audio processing path.",
    "Implement robust error handling and diagnostic logging throughout the codebase. All critical operations—including driver interactions and network communications—should incorporate automatic re‑initialization and fallback mechanisms, ensuring uninterrupted, rock‑solid performance during live operations.",
    "Adopt secure coding practices. Secure all external communications using TLS/SSL, rigorously validate all inputs (especially from remote control channels), and encrypt sensitive data at rest. Ensure that security mechanisms run asynchronously to avoid impacting real‑time audio playback.",
    "Design a responsive, intuitive user interface that leverages cross‑platform frameworks (JUCE for desktop, React Native for iOS). The UI should include a configurable 10x12 clip grid (with support for up to 8 full‑screen tabs and an optional dual‑tab view), and allow individual clip buttons to stretch up to 4 cells.",
    "Integrate a unified bottom panel that toggles between four distinct modes—Labelling, Editor, Routing, and Preferences. Only one mode is visible at any time, ensuring the main grid remains unobscured. Each mode must offer context‑specific controls: Labelling for editing clip labels and metadata; Editor for waveform display with transport controls, a Loop toggle, DSP controls, and IN/OUT time entry fields; Routing for configuring connections between application endpoints and audio hardware via a matrix; and Preferences for global settings and persistent playback controls.",
    "Ensure robust audio endpoint configuration: define outputs via Clip Groups A/B/C/D plus an Audition output (supporting up to five stereo streams) and inputs for Record A/B (up to two stereo streams) and LTC (one mono stream). Each stream, except LTC, must be configurable as Mono or Stereo, and in the absence of an external LTC signal, the system should default to the computer’s time‑of‑day.",
    "Integrate comprehensive session management. Support saving, loading, and duplicating complete session states—including clip order, grid layout, UI settings, and global performance modes—in a lightweight database (e.g., SQLite with JSON for complex fields). Ensure rapid lookup with indexed queries.",
    "Implement intelligent file recovery and media management. The application must automatically search for missing clip files using metadata, prompt for user confirmation when multiple candidates exist, and support project media folder selection and clip reconciliation across directories.",
    "For audio drivers, abstract platform-specific details into dedicated modules. On macOS, leverage CoreAudio (with Audio Units and AVAudioEngine) and support aggregated devices; on Windows, primarily use ASIO (with WASAPI exclusive mode as a fallback) with dynamic buffer and sample rate negotiation; on iOS, utilize CoreAudio and Audio Unit Extensions (AUv3) for low‑latency processing.",
    "Incorporate cross‑platform build and testing practices. Use CI/CD pipelines (e.g., GitHub Actions, Fastlane, Docker) to automate builds, testing, and deployment, ensuring consistent performance across macOS (including Apple Silicon and Intel), Windows, and iOS.",
    "Enforce a comprehensive logging system that captures detailed, timestamped events (clip playback, session state changes, driver interactions) and supports automated export in multiple formats (CSV, JSON, XML) with optional cloud syncing (Google Drive, Dropbox, AWS S3).",
    "Document all design decisions and code thoroughly. Include high‑fidelity UI mockups, detailed wireframes, system architecture diagrams, and ERDs for both clip and session metadata. Ensure this documentation remains version‑controlled and updated with each major release.",
    "Adopt a dynamic approach to driver detection and fallback. Continuously monitor audio performance metrics (buffer underruns, latency spikes) and switch drivers (ASIO to WASAPI, etc.) dynamically if instability is detected.",
    "Implement comprehensive testing across hardware platforms. Test the application on a wide range of audio interfaces and system configurations, document observed idiosyncrasies, and optimize performance based on real‑world usage scenarios.",
    "Maintain a high standard of code quality and security by enforcing secure coding standards (e.g., OWASP), performing regular code audits, and integrating automated testing (unit, integration, end‑to‑end) to ensure that both performance and security requirements are consistently met.",
    "Ensure that all updates and patches are digitally signed, with secure update mechanisms in place to prevent tampering. Use checksum and hash verification to validate update integrity before installation.",
    "Provide a robust, well‑documented API for all major modules to allow for future integration with third‑party systems and external controllers (including web‑based controllers if needed).",
    "Continuously evaluate and refine the system based on user feedback, performance metrics, and evolving industry standards to ensure the application remains state‑of‑the‑art."
  ]
}
