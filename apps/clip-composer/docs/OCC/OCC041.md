# OCC041 - Edit Dialog Critical Bug Fixes Sprint

**Date:** 2025-10-23
**Status:** Planning Complete, Ready for Implementation
**Type:** Bug Fix Sprint
**Target Version:** v0.2.3-alpha
**Trigger Phrase:** `"Execute Edit Dialog sprint"`

## Executive Summary

Six critical bugs identified in Edit Dialog (v0.2.2-alpha) preventing professional workflow. This sprint addresses fundamental UX issues with trim point editing, preview playback, and loop state management.

**Severity:** HIGH - Blocks professional audio editing workflow
**Estimated Effort:** 4-6 hours
**Files Affected:** 5 files (ClipEditDialog, PreviewPlayer, AudioEngine, ClipButton, MainComponent)

## Bugs Identified

### Bug #1: JUCE Font Assertion Failures (P1 - Critical)

**Symptom:**

```
JUCE Assertion failure in juce_String.cpp:327
[... repeated 100+ times during normal operation ...]
```

**Observed:** Lines 6-45 in `/tmp/occ.log` show persistent Font assertions despite OCC035 fix

**Root Cause:** Unknown - OCC035 claimed to fix all FontOptions usage, but assertions persist

**Impact:**

- Log spam (difficult debugging)
- Potential memory corruption
- Performance degradation from assertion overhead
- Undefined behavior in Release builds

**Investigation Needed:**

- Search entire codebase for remaining Font API misuse
- Check if issue is in JUCE internals or our code
- Verify all `setFont()` calls use correct API

**Acceptance Criteria:**

- [ ] Zero JUCE Font assertions in logs
- [ ] All Font constructors verified correct
- [ ] Clean `/tmp/occ.log` output during typical Edit Dialog session

---

### Bug #2: Setting IN Point Resets OUT Point (P1 - Critical)

**Symptom:** User sets IN point → OUT point jumps to 00:00:00.00, requiring manual clear

**Observed:** Log lines 64-65 show:

```
AudioEngine: Failed to update Cue Buss trim points: 18
PreviewPlayer: Trim points set to [-640, 0]
```

Negative trim values indicate validation failure causing OUT reset.

**Root Cause:**

1. **Validation logic in `ClipEditDialog::buildPhase2UI()`** (lines 423-426):

   ```cpp
   if (newInPoint >= m_metadata.trimOutSamples) {
     newInPoint = std::max(int64_t(0), m_metadata.trimOutSamples - (m_metadata.sampleRate / 75));
   }
   ```

   This clamps IN to be < OUT, but doesn't prevent OUT from being invalid.

2. **`PreviewPlayer::setTrimPoints()`** (lines 77-101):

   ```cpp
   if (trimInSamples >= trimOutSamples) {
     trimOutSamples = m_totalSamples; // RESETS OUT TO MAX
   }
   ```

   When IN >= OUT, PreviewPlayer resets OUT to file duration, breaking user's OUT point.

3. **Negative sample values** suggest arithmetic underflow when adjusting IN point near zero.

**Expected Behavior:**

- IN < OUT always maintained
- OUT >= IN always maintained
- OUT never changes unless user explicitly edits OUT
- Validation prevents invalid states without side effects

**Fix Strategy:**

1. Remove automatic OUT reset in `PreviewPlayer::setTrimPoints()`
2. Add validation in ClipEditDialog to prevent IN from exceeding OUT-1 tick
3. Ensure all trim point updates preserve OUT when only IN changes
4. Fix arithmetic to prevent negative sample values

**Acceptance Criteria:**

- [ ] User can adjust IN point from 00:00:00.00 to any value < OUT
- [ ] OUT point never changes unless user explicitly edits it
- [ ] No negative sample values in logs
- [ ] AudioEngine trim updates succeed (no error 18)

---

### Bug #3: Preview Player PLAY/STOP Buttons Don't Work (P1 - Critical)

**Symptom:** Clicking Play or Stop buttons in Edit Dialog has no effect on audio playback

**Observed:** No corresponding log entries when clicking Play/Stop in transport bar

**Root Cause Hypothesis:**

1. **`AudioEngine::startCueBuss()` may be toggle-based** (start/stop on each call)
   - Line 149 in `PreviewPlayer::play()` calls `startCueBuss()`
   - If already playing, this might stop instead of restart

2. **Button onClick handlers may not be firing**
   - Lines 363-381 in ClipEditDialog show callbacks defined
   - Need to verify callbacks are actually invoked

3. **Cue Buss handle may be invalid**
   - Line 144-146 checks `m_cueBussHandle == 0`
   - Log shows Cue Buss allocated (handle 10001), so this isn't the issue

**Investigation Needed:**

- Check `AudioEngine::startCueBuss()` implementation
- Verify it's idempotent (calling twice = still playing)
- Add debug logs to button onClick handlers

**Expected Behavior:**

- **Play button:** Always starts playback from IN point (restart if already playing)
- **Stop button:** Always stops playback

**Fix Strategy:**

1. Ensure `AudioEngine::startCueBuss()` is idempotent (not toggle)
2. OR: Add explicit state check in `PreviewPlayer::play()`:
   ```cpp
   void PreviewPlayer::play() {
     if (m_isPlaying) {
       stop(); // Explicit stop first
     }
     m_audioEngine->startCueBuss(m_cueBussHandle);
     m_isPlaying = true;
   }
   ```
3. Add DBG logs to button callbacks to verify they fire

**Acceptance Criteria:**

- [ ] Play button starts playback every time (logs confirm)
- [ ] Stop button stops playback every time (logs confirm)
- [ ] Clicking Play while playing restarts from IN point
- [ ] Transport position label updates during playback

---

### Bug #4: IN < > Buttons Alternate Play/Stop Instead of Restarting (P1 - Critical)

**Symptom:** Clicking IN < or > buttons: play/stop/play/stop/play/stop (alternating each click)

**Expected:** Should always restart playback from new IN point (play/play/play/play)

**Observed:** Log lines 79-404 show repeated pattern:

```
AudioEngine: Updated Cue Buss 10001 - Trim: [640, 4956140]
PreviewPlayer: Trim points set to [640, 4956140]
AudioEngine: Stopped Cue Buss 10001
PreviewPlayer: Stopped playback (Cue Buss 10001)
AudioEngine: Started Cue Buss 10001
PreviewPlayer: Started playback (Cue Buss 10001)
```

This confirms stop→play is being called, but may be toggling instead of restarting.

**Root Cause:**

**IN nudge button code** (lines 206-247 in ClipEditDialog):

```cpp
m_trimInDecButton->onClick = [this]() {
  // ... update trim point ...

  if (m_previewPlayer) {
    m_previewPlayer->setTrimPoints(m_metadata.trimInSamples, m_metadata.trimOutSamples);
    m_previewPlayer->stop(); // Stop first to force restart
    m_previewPlayer->play(); // Restart from new IN point
  }
};
```

This looks correct (stop→play), BUT:

**`AudioEngine::startCueBuss()` might be toggle-based:**

- If already stopped: starts
- If already started: STOPS (toggles)

So the pattern is:

1. User clicks <: stop() → play() → Cue Buss STARTS ✅
2. User clicks <: stop() → play() → Cue Buss already playing, so STOPS ❌
3. User clicks <: stop() → play() → Cue Buss STARTS ✅
4. Repeat alternation...

**Fix Strategy:**

**Option A: Fix AudioEngine API**

```cpp
// Make startCueBuss() idempotent (always starts, never toggles)
bool AudioEngine::startCueBuss(orpheus::ClipHandle handle) {
  auto it = m_cueBusses.find(handle);
  if (it == m_cueBusses.end()) return false;

  // ALWAYS start, regardless of current state
  return m_transportController->startClip(handle) == orpheus::SessionGraphError::OK;
}
```

**Option B: Fix PreviewPlayer logic**

```cpp
void PreviewPlayer::play() {
  // ALWAYS stop first to reset state
  if (m_isPlaying) {
    m_audioEngine->stopCueBuss(m_cueBussHandle);
  }

  // Then start fresh
  bool started = m_audioEngine->startCueBuss(m_cueBussHandle);
  m_isPlaying = started;
}
```

**Recommended: Option A** (fix at AudioEngine level for consistency)

**Acceptance Criteria:**

- [ ] Clicking IN < button 10 times = 10 restarts (continuous playback)
- [ ] Clicking IN > button 10 times = 10 restarts (continuous playback)
- [ ] No alternating play/stop pattern in logs
- [ ] Each click restarts from new IN point immediately

---

### Bug #5: Loop State Not Synced Between Edit Dialog and Clip Button (P2 - High)

**Symptom:** Enabling Loop in Edit Dialog doesn't enable Loop on clip button, and vice versa

**Expected:** Loop state should be global per clip - one toggle affects both

**Current Behavior:**

- Edit Dialog has `m_loopButton` (ToggleButton)
- Clip button has separate loop state
- No communication between them

**Architecture Issue:**

**Loop state lives in 3 places:**

1. `ClipButton` - per-button loop state
2. `ClipEditDialog::m_loopButton` - dialog-local toggle
3. `PreviewPlayer::m_loopEnabled` - preview-local flag

These are **not synchronized**.

**Impact:**

- User enables Loop in Edit Dialog → clicks OK → Loop not active on clip button
- User must manually enable Loop again after closing dialog
- Confusing UX (state changes don't persist)

**Fix Strategy:**

1. **Make ClipMetadata the source of truth:**

   ```cpp
   struct ClipMetadata {
     // ... existing fields ...
     bool loopEnabled = false; // ADD THIS
   };
   ```

2. **ClipEditDialog reads loop state from metadata:**

   ```cpp
   void ClipEditDialog::setClipMetadata(const ClipMetadata& metadata) {
     m_metadata = metadata;

     // Sync loop button to metadata
     if (m_loopButton) {
       m_loopButton->setToggleState(m_metadata.loopEnabled, juce::dontSendNotification);
     }

     // Sync preview player
     if (m_previewPlayer) {
       m_previewPlayer->setLoopEnabled(m_metadata.loopEnabled);
     }
   }
   ```

3. **ClipEditDialog updates metadata when loop toggled:**

   ```cpp
   m_loopButton->onClick = [this]() {
     m_metadata.loopEnabled = m_loopButton->getToggleState();

     if (m_previewPlayer) {
       m_previewPlayer->setLoopEnabled(m_metadata.loopEnabled);
     }
   };
   ```

4. **MainComponent syncs loop state to AudioEngine on OK:**

   ```cpp
   editDialog->onOkClicked = [this, buttonIndex](const ClipEditDialog::ClipMetadata& metadata) {
     // ... existing metadata updates ...

     // Update loop state in AudioEngine
     m_audioEngine->setClipLoop(buttonIndex, metadata.loopEnabled);
   };
   ```

**Acceptance Criteria:**

- [ ] Enabling Loop in Edit Dialog enables it on clip button after OK
- [ ] Clip button's loop state loads into Edit Dialog when opened
- [ ] Loop toggle in either location updates both
- [ ] Session save/load preserves loop state

---

### Bug #6: Loop Playback Not Implemented (P2 - High)

**Symptom:** Setting Loop toggle has no effect - audio doesn't loop

**Observed:** Log line 414:

```
PreviewPlayer: Loop enabled (not yet implemented in Cue Buss)
```

**Current State:**

**PreviewPlayer** (line 103-108):

```cpp
void PreviewPlayer::setLoopEnabled(bool shouldLoop) {
  m_loopEnabled = shouldLoop;
  // TODO: Implement loop mode in AudioEngine Cue Buss (future enhancement)
  DBG("PreviewPlayer: Loop enabled (not yet implemented in Cue Buss)");
}
```

**AudioEngine:** No loop support in Cue Buss system

**Impact:**

- User enables Loop → audio plays once and stops
- No way to audition looping behavior in Edit Dialog
- Can't verify loop points are correct before closing dialog

**Architecture Decision:**

Loop playback needs to be implemented at **AudioEngine level** (not PreviewPlayer):

**Why AudioEngine?**

1. Clip buttons also need loop functionality (not just preview)
2. Shared code prevents duplication
3. Sample-accurate loop points require audio thread control
4. Consistent behavior across preview and live playback

**Implementation Strategy:**

**1. Add loop support to TransportController (Orpheus SDK):**

```cpp
// In transport_controller.h:
struct ClipMetadata {
  // ... existing fields ...
  bool loop_enabled = false;
  int64_t loop_in_samples = 0;  // Usually same as trim_in
  int64_t loop_out_samples = 0; // Usually same as trim_out
};

// In transport_controller.cpp:
void TransportController::processAudio(...) {
  for (auto& clip : m_activeClips) {
    // ... existing playback logic ...

    if (clip.metadata.loop_enabled && clip.position >= clip.metadata.loop_out_samples) {
      clip.position = clip.metadata.loop_in_samples; // Restart at loop IN
    }
  }
}
```

**2. Add AudioEngine API:**

```cpp
// In AudioEngine.h:
void setClipLoop(int buttonIndex, bool loopEnabled);
void setCueBussLoop(orpheus::ClipHandle handle, bool loopEnabled);

// In AudioEngine.cpp:
void AudioEngine::setClipLoop(int buttonIndex, bool loopEnabled) {
  auto metadata = getClipMetadata(buttonIndex);
  if (metadata.has_value()) {
    // Update transport controller clip metadata
    m_transportController->setClipLoopEnabled(buttonIndex, loopEnabled);
  }
}
```

**3. Update PreviewPlayer:**

```cpp
void PreviewPlayer::setLoopEnabled(bool shouldLoop) {
  m_loopEnabled = shouldLoop;

  if (m_cueBussHandle != 0 && m_audioEngine) {
    m_audioEngine->setCueBussLoop(m_cueBussHandle, shouldLoop);
  }

  DBG("PreviewPlayer: Loop " << (shouldLoop ? "enabled" : "disabled"));
}
```

**Estimated Effort:** 2-3 hours (requires SDK changes)

**Acceptance Criteria:**

- [ ] Enabling Loop in Edit Dialog causes preview to loop between IN/OUT
- [ ] Enabling Loop on clip button causes clip to loop when triggered
- [ ] Loop is sample-accurate (no gaps or clicks at loop point)
- [ ] Disabling Loop stops looping and plays once through
- [ ] Loop state persists in session save/load

---

## Sprint Execution Plan

### Phase 1: Investigation & Validation (30 minutes)

**Tasks:**

1. Reproduce all 6 bugs in controlled test
2. Capture detailed logs for each bug
3. Verify root cause hypotheses
4. Identify any additional edge cases

**Deliverables:**

- Test log file with all 6 bugs demonstrated
- Confirmed root causes for each bug
- Updated acceptance criteria if needed

---

### Phase 2: Quick Wins (1 hour)

**Priority:** Fix bugs that don't require AudioEngine changes

**Bug #2: IN/OUT Point Validation**

```cpp
// ClipEditDialog.cpp - Remove OUT reset from validation
m_waveformDisplay->onLeftClick = [this](int64_t samples) {
  int64_t newInPoint = samples;

  // Clamp IN to valid range: [0, OUT - 1 tick]
  int64_t minIn = 0;
  int64_t maxIn = m_metadata.trimOutSamples - (m_metadata.sampleRate / 75);
  newInPoint = std::clamp(newInPoint, minIn, maxIn);

  m_metadata.trimInSamples = newInPoint;
  updateTrimInfoLabel();

  // Update displays WITHOUT affecting OUT
  if (m_waveformDisplay) {
    m_waveformDisplay->setTrimPoints(m_metadata.trimInSamples, m_metadata.trimOutSamples);
  }

  if (m_previewPlayer) {
    m_previewPlayer->setTrimPoints(m_metadata.trimInSamples, m_metadata.trimOutSamples);
  }
};

// PreviewPlayer.cpp - Remove OUT reset logic
void PreviewPlayer::setTrimPoints(int64_t trimInSamples, int64_t trimOutSamples) {
  // Clamp to file boundaries only
  if (m_totalSamples > 0) {
    trimInSamples = std::clamp(trimInSamples, int64_t(0), m_totalSamples);
    trimOutSamples = std::clamp(trimOutSamples, int64_t(0), m_totalSamples);

    // NO AUTOMATIC RESET OF OUT POINT
    // Just clamp, don't override
  }

  m_trimInSamples = trimInSamples;
  m_trimOutSamples = trimOutSamples;

  // ... rest unchanged
}
```

**Bug #5: Loop State Sync**

```cpp
// ClipEditDialog.h - Add to ClipMetadata struct
struct ClipMetadata {
  // ... existing fields ...
  bool loopEnabled = false; // ADDED
};

// ClipEditDialog.cpp - Sync loop state
void ClipEditDialog::setClipMetadata(const ClipMetadata& metadata) {
  m_metadata = metadata;

  // ... existing code ...

  // Sync loop button (ADDED)
  if (m_loopButton) {
    m_loopButton->setToggleState(m_metadata.loopEnabled, juce::dontSendNotification);
  }

  if (m_previewPlayer) {
    m_previewPlayer->setLoopEnabled(m_metadata.loopEnabled);
  }
}

// Update loop button callback (MODIFIED)
m_loopButton->onClick = [this]() {
  m_metadata.loopEnabled = m_loopButton->getToggleState();

  if (m_previewPlayer) {
    m_previewPlayer->setLoopEnabled(m_metadata.loopEnabled);
  }
};

// MainComponent.cpp - Sync on OK (ADDED)
editDialog->onOkClicked = [this, buttonIndex](const ClipEditDialog::ClipMetadata& metadata) {
  // ... existing updates ...

  // Update loop state
  m_clipGrid->setClipLoop(buttonIndex, metadata.loopEnabled);
};
```

**Testing:**

- [ ] IN point adjustments preserve OUT point
- [ ] Loop toggle in dialog syncs to clip button

---

### Phase 3: AudioEngine Fixes (2 hours)

**Priority:** Fix playback toggle behavior

**Bug #3 & #4: Make startCueBuss() Idempotent**

**Investigate AudioEngine::startCueBuss() first:**

```bash
grep -A 20 "bool.*startCueBuss" apps/clip-composer/Source/AudioEngine/AudioEngine.cpp
```

**Expected Fix:**

```cpp
// AudioEngine.cpp
bool AudioEngine::startCueBuss(orpheus::ClipHandle handle) {
  auto it = m_cueBusses.find(handle);
  if (it == m_cueBusses.end()) {
    return false;
  }

  // ALWAYS start, regardless of current state (idempotent)
  auto result = m_transportController->startClip(handle);

  if (result == orpheus::SessionGraphError::OK) {
    DBG("AudioEngine: Started Cue Buss " << handle);
    return true;
  } else {
    DBG("AudioEngine: Failed to start Cue Buss " << handle << " (error: " << static_cast<int>(result) << ")");
    return false;
  }
}
```

**If startClip() is also toggle-based, need deeper fix:**

```cpp
// Option: Explicit stop first
bool AudioEngine::startCueBuss(orpheus::ClipHandle handle) {
  // Stop first to reset state
  m_transportController->stopClip(handle);

  // Then start fresh
  auto result = m_transportController->startClip(handle);
  return result == orpheus::SessionGraphError::OK;
}
```

**Testing:**

- [ ] Play button works every time
- [ ] Stop button works every time
- [ ] IN < > buttons restart playback consistently

---

### Phase 4: Loop Playback Implementation (2-3 hours)

**Priority:** Enable actual loop functionality

**This requires SDK changes** - larger scope than other fixes

**1. Update Orpheus SDK TransportController:**

```cpp
// include/orpheus/transport_controller.h
struct ClipState {
  // ... existing fields ...
  bool loop_enabled = false;
  int64_t loop_in_samples = 0;
  int64_t loop_out_samples = 0;
};

// src/core/transport/transport_controller.cpp
void TransportController::processAudio(float** outputs, int numChannels, int numSamples) {
  for (auto& [handle, state] : m_playingClips) {
    // ... existing decode logic ...

    // Check for loop restart
    if (state.loop_enabled && state.position >= state.loop_out_samples) {
      state.position = state.loop_in_samples;
      DBG("TransportController: Clip " << handle << " looped to sample " << state.position);
    }

    // ... existing mixing logic ...
  }
}

// Add API to update loop state
SessionGraphError TransportController::setClipLoopEnabled(ClipHandle handle, bool loopEnabled) {
  auto it = m_playingClips.find(handle);
  if (it == m_playingClips.end()) {
    return SessionGraphError::CLIP_NOT_FOUND;
  }

  it->second.loop_enabled = loopEnabled;
  return SessionGraphError::OK;
}
```

**2. Update AudioEngine wrapper:**

```cpp
// AudioEngine.h
void setClipLoop(int buttonIndex, bool loopEnabled);
void setCueBussLoop(orpheus::ClipHandle handle, bool loopEnabled);

// AudioEngine.cpp
void AudioEngine::setClipLoop(int buttonIndex, bool loopEnabled) {
  if (buttonIndex < 0 || buttonIndex >= 960) return;

  auto metadata = getClipMetadata(buttonIndex);
  if (!metadata.has_value()) return;

  // Get clip handle and update transport controller
  // (assumes clip handle = buttonIndex for simplicity)
  m_transportController->setClipLoopEnabled(buttonIndex, loopEnabled);

  DBG("AudioEngine: Set loop for button " << buttonIndex << " = " << loopEnabled);
}

void AudioEngine::setCueBussLoop(orpheus::ClipHandle handle, bool loopEnabled) {
  m_transportController->setClipLoopEnabled(handle, loopEnabled);
  DBG("AudioEngine: Set loop for Cue Buss " << handle << " = " << loopEnabled);
}
```

**3. Update PreviewPlayer:**

```cpp
void PreviewPlayer::setLoopEnabled(bool shouldLoop) {
  m_loopEnabled = shouldLoop;

  if (m_cueBussHandle != 0 && m_audioEngine) {
    m_audioEngine->setCueBussLoop(m_cueBussHandle, shouldLoop);
  }

  DBG("PreviewPlayer: Loop " << (shouldLoop ? "enabled" : "disabled"));
}
```

**Testing:**

- [ ] Enable Loop → audio loops between IN/OUT
- [ ] Disable Loop → audio plays once
- [ ] Loop is sample-accurate (no glitches)
- [ ] Works for both preview (Cue Buss) and clip buttons

---

### Phase 5: Font Assertions (1 hour)

**Priority:** Final cleanup

**Investigation:**

```bash
# Search for all Font usage in codebase
grep -rn "Font(" apps/clip-composer/Source/ --include="*.cpp" --include="*.h" | grep -v "FontOptions"

# Look for deprecated API usage
grep -rn "setFont" apps/clip-composer/Source/ --include="*.cpp" --include="*.h"
```

**Likely causes:**

1. Missed Font constructors in previous fix
2. Font usage in base classes or JUCE internals
3. LookAndFeel font methods

**Fix strategy:**

- Replace all `juce::Font("Inter", size, style)` with modern API
- Check InterLookAndFeel for Font misuse
- Verify no Font creation in paint() methods (performance issue)

**Testing:**

- [ ] Zero Font assertions in `/tmp/occ.log`
- [ ] Full Edit Dialog session (load, edit, preview, save) produces clean logs

---

## Testing Protocol

### Pre-Sprint Baseline

```bash
# Launch app
apps/clip-composer/launch.sh

# Clear log
> /tmp/occ.log

# Test sequence:
1. Load clip to button 6
2. Double-click to open Edit Dialog
3. Click IN < 10 times (should alternate play/stop - BUG)
4. Set IN via waveform click (OUT should reset - BUG)
5. Click Play (should do nothing - BUG)
6. Enable Loop (should not loop - BUG)
7. Close dialog, check clip button loop state (should be OFF - BUG)

# Capture log
cat /tmp/occ.log > /tmp/occ-before-sprint.log
```

### Post-Sprint Validation

```bash
# Same test sequence after fixes:
1. Load clip to button 6
2. Double-click to open Edit Dialog
3. Click IN < 10 times (should restart 10 times - FIXED)
4. Set IN via waveform click (OUT should stay put - FIXED)
5. Click Play (should start playback - FIXED)
6. Enable Loop (should loop audio - FIXED)
7. Close dialog, check clip button loop state (should be ON - FIXED)

# Verify logs
cat /tmp/occ.log | grep "Assertion failure" # Expected: (none)
cat /tmp/occ.log | grep "Failed to update" # Expected: (none)
```

### Acceptance Criteria (All Bugs)

- [ ] **Bug #1:** Zero Font assertions in logs
- [ ] **Bug #2:** IN adjustments never affect OUT point
- [ ] **Bug #3:** Play/Stop buttons work every click
- [ ] **Bug #4:** IN < > buttons restart playback consistently
- [ ] **Bug #5:** Loop state syncs between dialog and button
- [ ] **Bug #6:** Loop playback works (audio actually loops)

---

## Risk Assessment

### High Risk Items

**1. AudioEngine API Changes**

- **Risk:** Breaking existing clip playback
- **Mitigation:** Test regular clip buttons after each AudioEngine change
- **Rollback:** Git stash available before AudioEngine modifications

**2. SDK TransportController Changes**

- **Risk:** Affecting other SDK users (if any)
- **Mitigation:** Keep changes backward-compatible (loop_enabled defaults to false)
- **Rollback:** SDK changes are additive, old code still works

**3. Loop State Serialization**

- **Risk:** Breaking session save/load
- **Mitigation:** Add loopEnabled to ClipMetadata struct (defaults to false for old sessions)
- **Rollback:** New field is optional, old sessions load without error

### Medium Risk Items

**4. PreviewPlayer Playback Logic**

- **Risk:** Breaking preview entirely
- **Mitigation:** Test preview after each PreviewPlayer change
- **Rollback:** PreviewPlayer changes are isolated, easy to revert

**5. Trim Point Validation**

- **Risk:** Creating new edge cases (e.g., IN = OUT - 1 tick)
- **Mitigation:** Comprehensive validation testing with boundary values
- **Rollback:** Validation logic is local to ClipEditDialog

---

## Files to Modify

### Core Changes (Required)

1. **apps/clip-composer/Source/UI/ClipEditDialog.h** - Add loopEnabled to ClipMetadata
2. **apps/clip-composer/Source/UI/ClipEditDialog.cpp** - Fix IN/OUT validation, sync loop state
3. **apps/clip-composer/Source/UI/PreviewPlayer.cpp** - Remove OUT reset, fix play/stop logic
4. **apps/clip-composer/Source/AudioEngine/AudioEngine.h** - Add loop APIs
5. **apps/clip-composer/Source/AudioEngine/AudioEngine.cpp** - Implement loop APIs, fix startCueBuss()

### SDK Changes (For Loop Playback)

6. **include/orpheus/transport_controller.h** - Add loop fields to ClipState
7. **src/core/transport/transport_controller.cpp** - Implement loop restart logic

### UI Updates (For Loop State Sync)

8. **apps/clip-composer/Source/MainComponent.cpp** - Sync loop state on dialog OK
9. **apps/clip-composer/Source/ClipGrid/ClipButton.h** - Expose setLoop() method (if needed)
10. **apps/clip-composer/Source/ClipGrid/ClipButton.cpp** - Implement setLoop() method (if needed)

---

## Success Metrics

**Definition of Done:**

1. All 6 bugs fixed and acceptance criteria met
2. Zero regressions in existing functionality
3. Clean log output (no assertions, no errors)
4. All manual tests pass
5. Code committed with comprehensive commit message
6. OCC041 marked as Complete

**Performance Targets:**

- Edit Dialog load time: <500ms (no change)
- Preview playback latency: <10ms (no change)
- Loop restart accuracy: ±1 sample (new requirement)

**User Experience Goals:**

- Professional trim editing workflow (no surprises)
- Intuitive loop behavior (matches SpotOn/Pro Tools)
- Reliable transport controls (always responsive)

---

## Documentation Updates

**After Sprint Completion:**

1. **Update OCC040** - Note bugs found in v0.2.2-alpha, link to OCC041
2. **Create OCC042** - v0.2.3-alpha Release Notes (bug fix summary)
3. **Update apps/clip-composer/docs/OCC/README.md** - Add OCC041, OCC042
4. **Update CHANGELOG** - List all 6 bug fixes with issue numbers

---

## Appendix A: Debug Commands

### Reproduce Bug #1 (Font Assertions)

```bash
tail -f /tmp/occ.log | grep "Assertion failure"
```

### Reproduce Bug #2 (IN/OUT Reset)

```bash
tail -f /tmp/occ.log | grep -E "(Failed to update|Trim points set to \[-)"
```

### Reproduce Bug #3 (Play/Stop Not Working)

```bash
tail -f /tmp/occ.log | grep -E "(Started playback|Stopped playback)"
# Expected: Logs appear when clicking Play/Stop
# Actual: No logs appear (bug)
```

### Reproduce Bug #4 (IN Nudge Toggle)

```bash
tail -f /tmp/occ.log | grep -E "(Started Cue Buss|Stopped Cue Buss)"
# Click IN < button 10 times
# Expected: 10 "Started" logs
# Actual: Alternating Started/Stopped (bug)
```

### Reproduce Bug #5 (Loop State Desync)

```bash
# In Edit Dialog: Enable Loop, click OK
# On Clip Button: Right-click, check loop state
# Expected: Loop enabled
# Actual: Loop disabled (bug)
```

### Reproduce Bug #6 (Loop Not Working)

```bash
tail -f /tmp/occ.log | grep "Loop"
# Enable Loop in Edit Dialog, play preview
# Expected: Audio loops indefinitely
# Actual: Plays once and stops (bug)
```

---

## Appendix B: Rollback Plan

If sprint fails or introduces regressions:

```bash
# Stash all changes
git stash save "OCC041 sprint - rollback"

# Return to v0.2.2-alpha state
git checkout e8301ff7  # Last known good commit

# Rebuild
cmake --build build --target orpheus_clip_composer_app

# Verify rollback successful
apps/clip-composer/launch.sh
```

---

## Trigger Phrase

**To execute this sprint:**

```
"Execute Edit Dialog sprint"
```

This will trigger the AI assistant to:

1. Read OCC041 in full
2. Execute phases 1-5 sequentially
3. Test after each phase
4. Commit changes incrementally
5. Report progress and blockers
6. Create final summary document (OCC042)

---

**Document Version:** 1.0
**Author:** Claude Code (Anthropic)
**Review Status:** Ready for Execution
**Estimated Duration:** 4-6 hours (with testing)
