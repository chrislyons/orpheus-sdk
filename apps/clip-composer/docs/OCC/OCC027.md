# OCC027 API Contracts: OCC ↔ Orpheus SDK Interfaces v1.0

**Document Version:** 1.0
**Date:** October 12, 2025
**Status:** Draft
**Supersedes:** None

---

## Executive Summary

This document defines the **precise API contracts** between Orpheus Clip Composer (OCC) and Orpheus SDK. These interfaces enable parallel development: OCC can be built against stub implementations while the SDK team develops the real audio engine.

**Purpose:**
- Establish clear interface boundaries
- Enable independent testing (mocking)
- Prevent tight coupling
- Support SDK evolution without breaking OCC

**Scope:**
- MVP interfaces only (required for OCC026 Milestone 1)
- C++20 interface definitions
- Thread safety guarantees
- Error handling contracts

**Not Covered:**
- Implementation details (SDK internal design)
- v1.0+ features (recording, DSP, remote control)
- Platform-specific drivers (abstracted by SDK)

---

## 1. Interface Overview

### 1.1 Core Interfaces (MVP Required)

| Interface | Responsibility | OCC Usage |
|-----------|----------------|-----------|
| `ISessionGraph` | Manage clips, tracks, tempo | Add/remove clips, retrieve clip metadata |
| `ITransportController` | Playback control, timing | Start/stop clips, query playback position |
| `IRoutingMatrix` | Multi-channel routing | Configure group outputs, audition routing |
| `IAudioFileReader` | Decode audio files | Load WAV/AIFF/FLAC, stream samples |
| `IPerformanceMonitor` | Real-time diagnostics | Query CPU usage, latency, dropouts |

### 1.2 Data Structures (Shared)

| Structure | Purpose |
|-----------|---------|
| `ClipHandle` | Opaque reference to a clip in SessionGraph |
| `AudioFormat` | Sample rate, bit depth, channel count |
| `TimePosition` | Sample-accurate time representation |
| `RoutingEndpoint` | Input or output channel identifier |
| `PerformanceMetrics` | CPU, latency, dropout statistics |

### 1.3 Interface Ownership

**SDK Provides (Implements):**
- All 5 core interfaces
- Audio thread management
- Driver integration (CoreAudio, ASIO, WASAPI)
- Lock-free communication primitives

**OCC Provides (Calls):**
- UI event handling
- Session JSON serialization/deserialization
- User interaction logic (FIFO choke, group management)
- Waveform rendering

**Boundary:**
- SDK is **pure audio engine** (no UI, no JSON, no file paths)
- OCC translates user actions into SDK API calls
- SDK notifies OCC via callbacks (playback state changes, errors)

---

## 2. ISessionGraph Interface

### 2.1 Purpose

Manages the audio session structure: clips, tracks, tempo, and transport state.

### 2.2 Header Definition

```cpp
namespace orpheus::sdk {

// Opaque handle to a clip (managed by SessionGraph)
struct ClipHandle {
    uint64_t id; // Internal identifier (not exposed to OCC)
    bool operator==(const ClipHandle& other) const { return id == other.id; }
};

// Audio file metadata
struct AudioFormat {
    uint32_t sampleRate;    // Hz (44100, 48000, etc.)
    uint16_t bitDepth;      // Bits (16, 24, 32)
    uint16_t channels;      // 1 = mono, 2 = stereo, etc.
    uint64_t durationSamples; // Total length in samples
};

// Clip metadata (subset of OCC022 schema relevant to SDK)
struct ClipMetadata {
    std::string filePath;       // Absolute path to audio file
    AudioFormat format;         // Audio file format
    int64_t trimInSamples;      // Trim IN point (0 = start of file)
    int64_t trimOutSamples;     // Trim OUT point (durationSamples = end)
    float fadeInSeconds;        // Fade in duration (linear)
    float fadeOutSeconds;       // Fade out duration (linear)
    bool loopEnabled;           // Loop playback continuously
    uint8_t clipGroup;          // 0=A, 1=B, 2=C, 3=D
};

// Error codes
enum class SessionGraphError {
    OK = 0,
    ClipNotFound,
    FileNotFound,
    UnsupportedFormat,
    OutOfMemory,
    InvalidParameter
};

// Result type (error handling)
template<typename T>
struct Result {
    T value;
    SessionGraphError error;
    std::string errorMessage;

    bool isOk() const { return error == SessionGraphError::OK; }
    bool isErr() const { return !isOk(); }
};

// ISessionGraph interface
class ISessionGraph {
public:
    virtual ~ISessionGraph() = default;

    // Clip management
    virtual Result<ClipHandle> addClip(const ClipMetadata& metadata) = 0;
    virtual SessionGraphError removeClip(ClipHandle handle) = 0;
    virtual SessionGraphError updateClip(ClipHandle handle, const ClipMetadata& metadata) = 0;
    virtual Result<ClipMetadata> getClipMetadata(ClipHandle handle) const = 0;
    virtual std::vector<ClipHandle> getAllClips() const = 0;

    // Tempo and timing
    virtual void setTempo(double bpm) = 0;
    virtual double getTempo() const = 0;
    virtual void setTimeSignature(uint8_t numerator, uint8_t denominator) = 0;

    // Session state
    virtual void clear() = 0; // Remove all clips
    virtual size_t getClipCount() const = 0;
};

} // namespace orpheus::sdk
```

### 2.3 Usage Example (OCC Side)

```cpp
// OCC loads a clip from JSON session file
void OCC::SessionManager::loadClipFromJSON(const nlohmann::json& clipJson) {
    orpheus::sdk::ClipMetadata metadata;
    metadata.filePath = clipJson["audio"]["file_path_absolute"];
    metadata.format.sampleRate = clipJson["audio"]["sample_rate"];
    metadata.format.bitDepth = clipJson["audio"]["bit_depth"];
    metadata.format.channels = clipJson["audio"]["channels"];
    metadata.format.durationSamples = clipJson["audio"]["duration_samples"];
    metadata.trimInSamples = clipJson["edit_points"]["trim_in_samples"];
    metadata.trimOutSamples = clipJson["edit_points"]["trim_out_samples"];
    metadata.fadeInSeconds = clipJson["fades"]["fade_in"]["duration_seconds"];
    metadata.fadeOutSeconds = clipJson["fades"]["fade_out"]["duration_seconds"];
    metadata.loopEnabled = clipJson["playback"]["loop_enabled"];
    metadata.clipGroup = clipGroupCharToInt(clipJson["playback"]["clip_group"]);

    auto result = sessionGraph->addClip(metadata);
    if (result.isErr()) {
        showError("Failed to load clip: " + result.errorMessage);
        return;
    }

    ClipHandle handle = result.value;
    clipHandles[clipJson["identity"]["uuid"]] = handle; // Map UUID → handle
}
```

### 2.4 Thread Safety Guarantee

**Thread-Safe Methods:**
- `getClipMetadata()` (const method, read-only)
- `getTempo()` (const method)
- `getClipCount()` (const method)
- `getAllClips()` (returns snapshot, safe to call from UI thread)

**NOT Thread-Safe (UI Thread Only):**
- `addClip()` - Allocates memory
- `removeClip()` - Frees memory
- `updateClip()` - Modifies state
- `setTempo()` - Modifies tempo
- `clear()` - Modifies session

**Audio Thread Access:**
- Audio thread NEVER calls SessionGraph directly
- Audio thread uses pre-loaded clip data (no dynamic lookups)

---

## 3. ITransportController Interface

### 3.1 Purpose

Controls playback state, sample-accurate timing, and transport commands.

### 3.2 Header Definition

```cpp
namespace orpheus::sdk {

// Time position (sample-accurate)
struct TimePosition {
    int64_t samples;   // Sample count since session start
    double seconds;    // Derived time in seconds (informational)

    static TimePosition fromSamples(int64_t s, uint32_t sampleRate) {
        return {s, static_cast<double>(s) / sampleRate};
    }
};

// Playback state
enum class PlaybackState {
    Stopped,
    Playing,
    Paused
};

// Transport callback (SDK → OCC notifications)
class ITransportCallback {
public:
    virtual ~ITransportCallback() = default;

    // Called when a clip starts playing
    virtual void onClipStarted(ClipHandle handle, TimePosition position) = 0;

    // Called when a clip stops (reached trim OUT or manually stopped)
    virtual void onClipStopped(ClipHandle handle, TimePosition position) = 0;

    // Called on playback error (file read error, driver dropout)
    virtual void onPlaybackError(ClipHandle handle, std::string error) = 0;
};

// ITransportController interface
class ITransportController {
public:
    virtual ~ITransportController() = default;

    // Playback control
    virtual SessionGraphError startClip(ClipHandle handle) = 0;
    virtual SessionGraphError stopClip(ClipHandle handle) = 0;
    virtual SessionGraphError stopAllClips() = 0;
    virtual SessionGraphError stopAllInGroup(uint8_t groupIndex) = 0; // 0=A, 1=B, 2=C, 3=D

    // Playback state queries
    virtual PlaybackState getClipState(ClipHandle handle) const = 0;
    virtual bool isClipPlaying(ClipHandle handle) const = 0;
    virtual TimePosition getClipPosition(ClipHandle handle) const = 0;

    // Global transport (future: session-level playback)
    virtual TimePosition getCurrentPosition() const = 0;

    // Callbacks
    virtual void setCallback(ITransportCallback* callback) = 0;
};

} // namespace orpheus::sdk
```

### 3.3 Usage Example (OCC Side)

```cpp
// OCC triggers a clip when user clicks button
void OCC::ClipTriggerEngine::triggerClip(const std::string& uuid) {
    ClipHandle handle = clipHandles[uuid];

    // FIFO choke: Stop other clips in same group
    if (fifoChokeEnabled) {
        uint8_t groupIndex = getClipGroup(handle);
        transport->stopAllInGroup(groupIndex);
    }

    // Start playback
    auto err = transport->startClip(handle);
    if (err != SessionGraphError::OK) {
        showError("Failed to trigger clip");
        return;
    }

    // UI updates happen via callback (onClipStarted)
}

// OCC receives playback notifications
class OCC::TransportCallbackImpl : public orpheus::sdk::ITransportCallback {
public:
    void onClipStarted(ClipHandle handle, TimePosition position) override {
        std::string uuid = handleToUUID[handle];
        uiThread->post([uuid]() {
            gridView->setButtonState(uuid, ButtonState::Playing);
        });
    }

    void onClipStopped(ClipHandle handle, TimePosition position) override {
        std::string uuid = handleToUUID[handle];
        uiThread->post([uuid]() {
            gridView->setButtonState(uuid, ButtonState::Stopped);
        });
    }

    void onPlaybackError(ClipHandle handle, std::string error) override {
        showError("Playback error: " + error);
    }
};
```

### 3.4 Thread Safety Guarantee

**Thread-Safe Methods:**
- `getClipState()` (const, lock-free atomic read)
- `isClipPlaying()` (const, lock-free atomic read)
- `getClipPosition()` (const, lock-free atomic read)
- `getCurrentPosition()` (const, lock-free atomic read)

**UI Thread Only:**
- `startClip()` - Posts command to audio thread via lock-free queue
- `stopClip()` - Posts command to audio thread
- `stopAllClips()` - Posts command
- `stopAllInGroup()` - Posts command
- `setCallback()` - Registers callback pointer

**Callback Invocation:**
- Callbacks invoked from **UI thread** (not audio thread)
- SDK uses lock-free queue to marshal events from audio → UI thread
- Callbacks NEVER block (fast execution required)

---

## 4. IRoutingMatrix Interface

### 4.1 Purpose

Configures multi-channel audio routing between application endpoints and hardware outputs.

### 4.2 Header Definition

```cpp
namespace orpheus::sdk {

// Routing endpoint (source or destination)
struct RoutingEndpoint {
    enum class Type { ClipGroup, Audition, HardwareOutput };

    Type type;
    uint8_t index; // Group index (0-3), or output index (0-15)

    static RoutingEndpoint clipGroup(uint8_t groupIndex) {
        return {Type::ClipGroup, groupIndex};
    }

    static RoutingEndpoint audition() {
        return {Type::Audition, 0};
    }

    static RoutingEndpoint hardwareOutput(uint8_t outputIndex) {
        return {Type::HardwareOutput, outputIndex};
    }
};

// Routing connection (stereo pair)
struct RoutingConnection {
    RoutingEndpoint source;        // Clip Group or Audition
    RoutingEndpoint destination;   // Hardware Output
    bool enabled;
};

// IRoutingMatrix interface
class IRoutingMatrix {
public:
    virtual ~IRoutingMatrix() = default;

    // Configure routing
    virtual SessionGraphError setRouting(const RoutingEndpoint& source,
                                          const RoutingEndpoint& dest,
                                          bool enabled) = 0;

    // Query routing
    virtual bool isRouted(const RoutingEndpoint& source,
                          const RoutingEndpoint& dest) const = 0;

    // Bulk operations
    virtual std::vector<RoutingConnection> getAllConnections() const = 0;
    virtual SessionGraphError applyRoutingPreset(const std::vector<RoutingConnection>& connections) = 0;

    // Device info
    virtual uint8_t getOutputCount() const = 0; // Number of available hardware outputs
};

} // namespace orpheus::sdk
```

### 4.3 Usage Example (OCC Side)

```cpp
// OCC sets default routing for Clip Group A → Outputs 1-2
void OCC::SessionManager::setupDefaultRouting() {
    auto source = RoutingEndpoint::clipGroup(0); // Group A
    auto dest1 = RoutingEndpoint::hardwareOutput(0); // Output 1 (left)
    auto dest2 = RoutingEndpoint::hardwareOutput(1); // Output 2 (right)

    routingMatrix->setRouting(source, dest1, true);
    routingMatrix->setRouting(source, dest2, true);

    // Audition → Outputs 9-10
    auto auditionSrc = RoutingEndpoint::audition();
    auto auditionDest1 = RoutingEndpoint::hardwareOutput(8);
    auto auditionDest2 = RoutingEndpoint::hardwareOutput(9);

    routingMatrix->setRouting(auditionSrc, auditionDest1, true);
    routingMatrix->setRouting(auditionSrc, auditionDest2, true);
}

// OCC saves routing as preset
nlohmann::json OCC::SessionManager::exportRoutingPreset() {
    auto connections = routingMatrix->getAllConnections();
    nlohmann::json preset = nlohmann::json::array();

    for (const auto& conn : connections) {
        if (conn.enabled) {
            preset.push_back({
                {"source_type", static_cast<int>(conn.source.type)},
                {"source_index", conn.source.index},
                {"dest_index", conn.destination.index}
            });
        }
    }

    return preset;
}
```

### 4.4 Thread Safety Guarantee

**Thread-Safe Methods:**
- `isRouted()` (const, lock-free atomic read)
- `getAllConnections()` (returns snapshot)
- `getOutputCount()` (const)

**UI Thread Only:**
- `setRouting()` - Modifies routing matrix (atomic update visible to audio thread)
- `applyRoutingPreset()` - Bulk updates

**Real-Time Application:**
- Routing changes apply **immediately** (next audio buffer)
- No clicks or pops when routing changes (crossfade applied internally)

---

## 5. IAudioFileReader Interface

### 5.1 Purpose

Abstract interface for decoding audio files (WAV, AIFF, FLAC, MP3, etc.).

### 5.2 Header Definition

```cpp
namespace orpheus::sdk {

// Audio buffer (interleaved samples)
struct AudioBuffer {
    float* samples;         // Interleaved float32 samples
    size_t frameCount;      // Number of frames (samples / channels)
    uint8_t channels;       // Channel count

    // Helper: Get sample at frame index and channel
    float getSample(size_t frame, uint8_t channel) const {
        return samples[frame * channels + channel];
    }
};

// IAudioFileReader interface
class IAudioFileReader {
public:
    virtual ~IAudioFileReader() = default;

    // Open file for reading
    virtual SessionGraphError open(const std::string& filePath) = 0;

    // Close file
    virtual void close() = 0;

    // Get file format
    virtual AudioFormat getFormat() const = 0;

    // Read samples (streaming)
    // Returns number of frames actually read (may be less than requested if EOF reached)
    virtual size_t read(AudioBuffer& buffer, size_t maxFrames) = 0;

    // Seek to sample position
    virtual SessionGraphError seek(int64_t samplePosition) = 0;

    // Query state
    virtual bool isOpen() const = 0;
    virtual int64_t getCurrentPosition() const = 0; // In samples
    virtual bool isEOF() const = 0;
};

// Factory function (SDK provides implementation)
std::unique_ptr<IAudioFileReader> createAudioFileReader(const std::string& filePath);

} // namespace orpheus::sdk
```

### 5.3 Usage Example (OCC Side)

```cpp
// OCC loads waveform data for editor display
void OCC::WaveformRenderer::loadWaveform(const std::string& filePath) {
    auto reader = orpheus::sdk::createAudioFileReader(filePath);

    auto err = reader->open(filePath);
    if (err != SessionGraphError::OK) {
        showError("Failed to open audio file");
        return;
    }

    AudioFormat format = reader->getFormat();
    size_t totalSamples = format.durationSamples;

    // Downsample for waveform display (e.g., 1 sample per 1000 for visualization)
    size_t downsampleFactor = 1000;
    std::vector<float> waveformData;
    waveformData.reserve(totalSamples / downsampleFactor);

    AudioBuffer buffer;
    float samples[4096 * 2]; // Temp buffer (stereo)
    buffer.samples = samples;
    buffer.channels = format.channels;

    while (!reader->isEOF()) {
        size_t framesRead = reader->read(buffer, 4096);

        // Compute RMS for each block
        for (size_t i = 0; i < framesRead; i += downsampleFactor) {
            float rms = 0.0f;
            for (uint8_t ch = 0; ch < format.channels; ++ch) {
                float sample = buffer.getSample(i, ch);
                rms += sample * sample;
            }
            rms = std::sqrt(rms / format.channels);
            waveformData.push_back(rms);
        }
    }

    reader->close();
    renderWaveform(waveformData);
}
```

### 5.4 Thread Safety Guarantee

**NOT Thread-Safe:**
- `IAudioFileReader` is **single-threaded** (one instance per thread)
- OCC must create separate `IAudioFileReader` instances for UI (waveform rendering) and audio thread (playback)

**Audio Thread Usage:**
- SDK manages `IAudioFileReader` instances internally for playback
- OCC never directly reads audio in audio thread (SDK handles this)

---

## 6. IPerformanceMonitor Interface

### 6.1 Purpose

Provides real-time diagnostics (CPU usage, latency, dropouts).

### 6.2 Header Definition

```cpp
namespace orpheus::sdk {

// Performance statistics
struct PerformanceMetrics {
    float cpuUsagePercent;      // Audio thread CPU usage (0-100%)
    float latencyMs;            // Current audio latency (milliseconds)
    uint64_t dropoutCount;      // Total buffer underruns/overruns since start
    uint64_t activeClipCount;   // Number of clips currently playing
    uint64_t totalSamplesProcessed; // Total samples rendered since start
};

// IPerformanceMonitor interface
class IPerformanceMonitor {
public:
    virtual ~IPerformanceMonitor() = default;

    // Get current metrics (thread-safe snapshot)
    virtual PerformanceMetrics getMetrics() const = 0;

    // Reset counters
    virtual void resetCounters() = 0;
};

} // namespace orpheus::sdk
```

### 6.3 Usage Example (OCC Side)

```cpp
// OCC updates performance display every 100ms
void OCC::PerformanceDisplay::update() {
    auto metrics = performanceMonitor->getMetrics();

    cpuMeter->setValue(metrics.cpuUsagePercent);
    latencyLabel->setText(std::format("{:.1f} ms", metrics.latencyMs));

    if (metrics.dropoutCount > lastDropoutCount) {
        dropoutIndicator->flash(); // Visual warning
        lastDropoutCount = metrics.dropoutCount;
    }

    activeClipsLabel->setText(std::format("{} clips playing", metrics.activeClipCount));
}
```

### 6.4 Thread Safety Guarantee

**Thread-Safe Methods:**
- `getMetrics()` (const, returns atomic snapshot)

**UI Thread Only:**
- `resetCounters()` (modifies state)

---

## 7. SDK Initialization & Lifecycle

### 7.1 SDK Factory Pattern

```cpp
namespace orpheus::sdk {

// SDK configuration
struct SDKConfig {
    // Audio driver selection
    std::string preferredDriver; // "CoreAudio", "ASIO", "WASAPI", "Auto"
    uint32_t sampleRate;         // 44100, 48000, 96000
    uint32_t bufferSize;         // 64, 128, 256, 512, 1024, 2048

    // Performance
    bool enableThreadPriority;   // Boost audio thread priority
    bool enableSIMD;             // Use SIMD optimizations
};

// Main SDK entry point
class OrpheusSDK {
public:
    // Initialize SDK with configuration
    static std::unique_ptr<OrpheusSDK> create(const SDKConfig& config);

    virtual ~OrpheusSDK() = default;

    // Get interfaces
    virtual ISessionGraph* getSessionGraph() = 0;
    virtual ITransportController* getTransportController() = 0;
    virtual IRoutingMatrix* getRoutingMatrix() = 0;
    virtual IPerformanceMonitor* getPerformanceMonitor() = 0;

    // Lifecycle
    virtual SessionGraphError start() = 0; // Start audio engine
    virtual void stop() = 0;              // Stop audio engine
    virtual bool isRunning() const = 0;
};

} // namespace orpheus::sdk
```

### 7.2 OCC Initialization Example

```cpp
// OCC application startup
void OCC::Application::initialize() {
    // Configure SDK
    orpheus::sdk::SDKConfig config;
    config.preferredDriver = "Auto"; // Let SDK choose best driver
    config.sampleRate = 48000;
    config.bufferSize = 256; // ~5ms latency at 48kHz
    config.enableThreadPriority = true;
    config.enableSIMD = true;

    // Create SDK instance
    sdk = orpheus::sdk::OrpheusSDK::create(config);

    // Get interfaces
    sessionGraph = sdk->getSessionGraph();
    transport = sdk->getTransportController();
    routingMatrix = sdk->getRoutingMatrix();
    performanceMonitor = sdk->getPerformanceMonitor();

    // Register callbacks
    transport->setCallback(new TransportCallbackImpl());

    // Start audio engine
    auto err = sdk->start();
    if (err != SessionGraphError::OK) {
        showFatalError("Failed to initialize audio engine");
        exit(1);
    }

    // Setup default routing
    setupDefaultRouting();
}

void OCC::Application::shutdown() {
    // Stop audio engine
    sdk->stop();

    // Cleanup (SDK interfaces deleted automatically when sdk goes out of scope)
    sdk.reset();
}
```

---

## 8. Error Handling Contract

### 8.1 Error Reporting Strategy

**Synchronous Errors:**
- Methods return `SessionGraphError` enum or `Result<T>`
- Errors returned immediately (no exceptions thrown)
- Error messages included in `Result::errorMessage`

**Asynchronous Errors:**
- Delivered via callbacks (e.g., `ITransportCallback::onPlaybackError`)
- Audio thread never throws exceptions (catches all, logs, continues)

### 8.2 Error Categories

| Error | Severity | OCC Response |
|-------|----------|--------------|
| `ClipNotFound` | Warning | Show message, continue |
| `FileNotFound` | Error | Show error dialog, offer file location |
| `UnsupportedFormat` | Error | Show error, suggest conversion |
| `OutOfMemory` | Critical | Show error, suggest closing clips |
| `InvalidParameter` | Bug | Assert/log, report bug |

### 8.3 Error Handling Example

```cpp
// OCC robust error handling
void OCC::SessionManager::loadClip(const std::string& filePath) {
    ClipMetadata metadata = parseFilePath(filePath);

    auto result = sessionGraph->addClip(metadata);

    if (result.isErr()) {
        switch (result.error) {
            case SessionGraphError::FileNotFound:
                showError("Audio file not found: " + filePath);
                offerFileLocation();
                break;

            case SessionGraphError::UnsupportedFormat:
                showError("Unsupported audio format. Supported: WAV, AIFF, FLAC");
                break;

            case SessionGraphError::OutOfMemory:
                showError("Out of memory. Close some clips and try again.");
                break;

            default:
                showError("Failed to load clip: " + result.errorMessage);
                break;
        }
        return;
    }

    ClipHandle handle = result.value;
    // Success - continue processing
}
```

---

## 9. Stub Implementation for Parallel Development

### 9.1 Purpose

Enable OCC development before Orpheus SDK is fully implemented.

### 9.2 Stub Interface Example

```cpp
// Stub implementation of ISessionGraph (OCC/tests/stubs/StubSessionGraph.h)
namespace occ::stubs {

class StubSessionGraph : public orpheus::sdk::ISessionGraph {
private:
    std::map<uint64_t, orpheus::sdk::ClipMetadata> clips;
    uint64_t nextId = 1;
    double tempo = 120.0;

public:
    Result<ClipHandle> addClip(const ClipMetadata& metadata) override {
        ClipHandle handle{nextId++};
        clips[handle.id] = metadata;
        return {handle, SessionGraphError::OK, ""};
    }

    SessionGraphError removeClip(ClipHandle handle) override {
        if (clips.erase(handle.id) == 0) {
            return SessionGraphError::ClipNotFound;
        }
        return SessionGraphError::OK;
    }

    Result<ClipMetadata> getClipMetadata(ClipHandle handle) const override {
        auto it = clips.find(handle.id);
        if (it == clips.end()) {
            return {{}, SessionGraphError::ClipNotFound, "Clip not found"};
        }
        return {it->second, SessionGraphError::OK, ""};
    }

    // ... other methods (simple stub logic)
};

} // namespace occ::stubs
```

### 9.3 Usage in OCC Tests

```cpp
// OCC unit test using stub
TEST(SessionManager, LoadClipFromJSON) {
    // Use stub instead of real SDK
    auto stubGraph = std::make_unique<occ::stubs::StubSessionGraph>();

    SessionManager manager(stubGraph.get());

    nlohmann::json clipJson = {
        {"identity", {{"uuid", "test-uuid"}}},
        {"audio", {{"file_path_absolute", "/tmp/test.wav"}, ...}},
        // ... rest of JSON
    };

    manager.loadClipFromJSON(clipJson);

    // Verify clip was added to graph
    ASSERT_EQ(stubGraph->getClipCount(), 1);
}
```

---

## 10. Interface Versioning & Evolution

### 10.1 ABI Stability

**SDK Version:** `orpheus::sdk::Version{major, minor, patch}`

**Compatibility Rules:**
- **Major version change:** Breaking ABI changes allowed (OCC must recompile)
- **Minor version change:** New methods/features, backward compatible
- **Patch version change:** Bug fixes only, fully compatible

### 10.2 Version Negotiation

```cpp
namespace orpheus::sdk {

struct Version {
    uint16_t major;
    uint16_t minor;
    uint16_t patch;

    std::string toString() const {
        return std::format("{}.{}.{}", major, minor, patch);
    }
};

class OrpheusSDK {
public:
    // Query SDK version
    static Version getVersion();

    // Check compatibility
    static bool isCompatible(const Version& requiredVersion);
};

} // namespace orpheus::sdk
```

### 10.3 OCC Version Check

```cpp
// OCC startup: Verify SDK compatibility
void OCC::Application::checkSDKVersion() {
    auto sdkVersion = orpheus::sdk::OrpheusSDK::getVersion();
    auto requiredVersion = orpheus::sdk::Version{1, 0, 0}; // OCC requires SDK 1.0.0+

    if (!orpheus::sdk::OrpheusSDK::isCompatible(requiredVersion)) {
        showFatalError(
            std::format("Incompatible Orpheus SDK version.\n"
                       "Required: {}\n"
                       "Found: {}",
                       requiredVersion.toString(),
                       sdkVersion.toString())
        );
        exit(1);
    }
}
```

---

## 11. Future Interfaces (v1.0+)

**Deferred to v1.0:**

```cpp
// IInputAudioGraph (recording support)
class IInputAudioGraph {
    virtual SessionGraphError startRecording(const std::string& outputPath) = 0;
    virtual SessionGraphError stopRecording() = 0;
    virtual bool isRecording() const = 0;
};

// IDSPProcessor (time-stretch, pitch-shift)
class IDSPProcessor {
    virtual SessionGraphError setTimeStretch(ClipHandle handle, float ratio) = 0;
    virtual SessionGraphError setPitchShift(ClipHandle handle, float semitones) = 0;
};

// IRemoteControlServer (WebSocket, OSC, MIDI)
class IRemoteControlServer {
    virtual SessionGraphError start(uint16_t port) = 0;
    virtual void stop() = 0;
    virtual bool isRunning() const = 0;
};
```

**Deferred to v2.0:**
- `IPluginHost` (VST3 hosting)
- `ISpatialAudioRenderer` (3D audio)
- `IInteractionRulesEngine` (Ovation-style rules)

---

## 12. Related Documents

- **OCC022** - Clip Metadata Schema (OCC's JSON data model)
- **OCC023** - Component Architecture (system design context)
- **OCC026** - Milestone 1 MVP Definition (feature scope)
- **Orpheus SDK AGENTS.md** - SDK coding guidelines

---

## 13. Appendices

### Appendix A: Complete Interface Summary

| Interface | Methods | Thread Safety | MVP Required |
|-----------|---------|---------------|--------------|
| `ISessionGraph` | 10 | UI thread only (except const) | ✅ Yes |
| `ITransportController` | 8 | UI thread for commands, callbacks on UI thread | ✅ Yes |
| `IRoutingMatrix` | 5 | UI thread for writes, const methods thread-safe | ✅ Yes |
| `IAudioFileReader` | 7 | Single-threaded (one instance per thread) | ✅ Yes |
| `IPerformanceMonitor` | 2 | Thread-safe | ✅ Yes |
| `OrpheusSDK` | 7 | UI thread only | ✅ Yes |

### Appendix B: Data Structure Sizes

| Structure | Size (bytes) | Alignment |
|-----------|--------------|-----------|
| `ClipHandle` | 8 | 8 |
| `AudioFormat` | 16 | 4 |
| `ClipMetadata` | ~256 | 8 |
| `TimePosition` | 16 | 8 |
| `RoutingEndpoint` | 2 | 1 |
| `PerformanceMetrics` | 40 | 8 |

---

**Document Status:** Ready for SDK team implementation and OCC stub development.
**Next Steps:** SDK team implements interfaces, OCC team builds against stubs.
